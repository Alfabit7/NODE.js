# Урок 1
Предпосылки к созданию Node.js

## Что такое Node.js?
Раян Даль - Американский инженер-программист cоздатель Node.js
`Node.js` — это платформа, которая позволяет разработчикам
писать серверную часть программ на JavaScript.


## Как Node.js работает “под капотом”?

Событийная модель в Node.js
Каждый запрос клиента не блокируется
другими запросами.
* Выполнение кода происходит в одном потоке,
что позволяет не думать о параллельном
доступе к памяти
* Пока в рамках одного запроса приложение
делает запрос в БД или читает файл, Node.js
не простаивает и обрабатывает запросы
от других клиентов
* Такой подход не так требователен
к ресурсам железа

Чтобы разобраться с принципом работы Node.js, нужно понять, из чего он состоит.

*V8 — это среда, которая интерпретирует и компилирует JavaScript-код в машинный код. V8 также поддерживает возможности ECMAScript 6: классы,
стрелочные функции, промисы и другие. Такая среда исполнения работает в браузере Google Chrome и многих других.
* libUV — это библиотека на языке C, которая используется в Node.js для
обработки асинхронных операций ввода-вывода (I/O). Она отвечает за
предоставление асинхронных операций I/O и управление событийным
циклом.
* Менеджер пакетов NPM — это программа, которая позволяет устанавливать
и использовать дополнительные модули и библиотеки из общедоступного
репозитория. Об NPM мы подробно поговорим во второй лекции.

Контекст выполнения — это механизм, который позволяет интерпретатору
понимать, какие переменные и функции доступны для использования в текущий
момент.
Существует два контекста выполнения:
* Глобальный — создается при запуске скрипта. В него записываются все
переменные и функции, которые мы определим в скрипте.
* Контекст функции — создается во время вызова функции. В него
записываются переменные и функции, которые были определены внутри
исходной функции

Стек — это абстрактный тип данных, представляющий собой список элементов,
организованных по принципу LIFO (last in, first out), то есть последний добавленный
элемент будет первым удаленным. Чаще всего принцип работы стека сравнивают
со стопкой тарелок: есть стопка из трех тарелок, чтобы взять вторую, нужно сначала
взять третью.

Стек вызовов (call stack) — это механизм для отслеживания текущего контекста и
порядка вызовов функций. Каждый раз, когда функция вызывается, она
добавляется в стек вызовов. Когда функция завершается, она удаляется из стека
вызовов.


При запуске скрипта всегда создается глобальный контекст.
* Все объявленные переменные и функции в скрипте записываются в
глобальный контекст.
* Вызов функции создает новый контекст, и он добавляется в стек вызовов.
* Если в текущем контексте функции нет искомой переменной или функции,
интерпретатор ищет переменные и функции в контексте ниже по стеку.
* Для функций может быть создано столько контекстов, сколько позволяет
размер стека вызовов.

## Как связан интерпретатор V8 с библиотекой libUV?

В интернете часто говорят, что JavaScript выполняется в единственном потоке и не
имеет возможности параллельного выполнения кода. Это не совсем верно, так как
рассматривать JavaScript в отрыве от платформы, на которой он запускается,
некорректно.

Правильнее будет сказать, что движок, который интерпретирует JavaScript,
работает в одном потоке, но платформа, в рамках которой запускается движок,
позволяет достигнуть параллелизма в некоторых случаях, в том числе за счет
потоков.

В Node.js используется движок V8, и сам по себе он интерпретирует и выполняет
JavaScript-код в одном потоке выполнения. Это значит, что невозможно выполнить
две операции параллельно, код будет выполняться в том порядке, в котором был
написан, согласно правилам исполнения кода в JavaScript. Но в Node.js, помимо
самого движка V8, есть еще библиотека libUV.

```javascript 
setTimeout(() => {
  console.log('log in settimeout');
}, 1000);
console.log('log in global context');
```

При запуске скрипта с помощью Node.js инициализируется движок V8. В него
передаются разные переменные и функции, которые не являются частью
интерпретатора, такие как setTimeout. 

Когда мы вызываем setTimeout, мы передаем nв него два аргумента — колбек и время, через которое нужно вызвать
соответствующий колбек. Тут и происходит магия. Адрес колбека, который мы передаем, отправляется в libUV вместе с временем, через которое нужно вызвать этот колбек.

 Далее libUV инициализирует внутри себя таймер и постоянно
проверяет, не пришло ли время выполнить колбек. Как раз поэтому V8 свободен и
может выполнять код дальше, ведь таймер обрабатывается на стороне libUV.

1. При запуске скрипта инициализируется V8 и LibUV.
2. Далее начинается выполнение кода. Запускается функция setTimeout, ивызов функции добавляется в стек вызовов.
3. Как только функция setTimeout попадает в стек вызовов, происходит передача всех необходимых данных библиотеке libUV — это адрес колбека,
инициализированного в первом аргументе setTimeout(), и время таймера из второго аргумента.

4. Далее выполнение функции setTimeout завершается, и контекст функции извлекается из стека вызовов V8. Но что происходит в libUV? Здесь стоит
пояснить, что такое цикл событий. Цикл событий — это бесконечный цикл, который работает до тех пор, пока в
нем есть какие-либо задачи на выполнение. В нашем случае в цикл событий попадает таймер, и цикл на каждой итерации проверяет, достиг ли таймер
нужного времени.

<image src="./images/1.jpg">

5. После выполнения setTimeout на пятой строчке выполняется функция log()
глобального объекта console. Она добавляется в стек вызовов. Обратите внимание, что пока выполняется функция log(), в цикле событий содержится задача-таймер, которая еще не выполнилась, так как не пришло время.

6. После того как выполнится функция log() на пятой строчке, ее контекст
извлечется из стека событий. После этого в коде нечего выполнять. Но
Node.js не прекратит выполнение скрипта, так как есть зарегистрированная
задача в цикле событий. Что же произойдет, когда таймер достигнет нужного
времени? Адрес колбека передастся в очередь колбеков Callback Queue.
Очередь колеков нужна для того, чтобы хранить адреса функций, которые
нужно выполнить в интерпретаторе

<image src="./images/2.jpg">

7. После того как адрес колбека передастся в очередь колбеков, libUV проверит стек вызовов в V8. Если он окажется пустым (и только в этом случае), передаст в стек вызовов адрес функции, а V8 создаст для колбека контекст и начнет выполнять этот колбек.

<image src="./images/3.jpg">

8. Далее, так как в интерпретаторе была вызвана функция колбек, выполняется
тело этой функции и запускается функция log() глобального объекта console.
Эта функция добавляется в стек вызовов.

<image src="./images/4.jpg">

9. Когда выполнится функция log(), ее контекст извлечется из стека вызовов.

10. После этого, так как в колбеке больше нет кода, колбек также завершает свое выполнение и извлекается из стека вызовов.

Чтобы лучше понять работу Node.js, можно использовать
[Loupe](http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D) — инструмент визуализации работы v8 и цикла событий. 

<u>Важно знать, что Loupe не умеет работать со стрелочными функциями.</u>

***В браузере вместо libUV трудится библиотека WebAPI.***


## Резюмируя все, что мы разобрали касаемо работы Node.js, можем выделить важные тезисы:
* V8 работает в одном потоке, но libUV забирает на себя часть асинхронных задач, что позволяет не останавливать работу интерпретатора.
* Цикл событий в libUV — это бесконечный цикл, который работает до тех пор, пока есть задачи на выполнение и интерпретатор выполняет код.
* Помимо таймеров, libUV позволяет выполнять различные задачи: чтение и запись файлов, обработку сетевых запросов, запуск отдельных потоков и многое другое. Все это будет выполняться в рамках libUV, эти задачи не будут блокировать выполнение кода интерпретатором

## Установка Node.js

Зайдите на официальный сайт [nodejs](https://nodejs.org/en) и перейдите в раздел DOWNLOADS.

После установки Node.js его работоспособность можно проверить командой
`node -v` Эта команда позволяет узнать,
какая версия Node.js установлена на компьютере

## Способы запуска кода

Есть два способа запустить Javascript-код в Node.js — REPL и запуск файла с JS-кодом. Для начала разберемся, что такое REPL.

***REPL*** (Read-Eval-Print Loop) — это интерактивная оболочка для исполнения кода в Node.js в консоли. REPL позволяет вводить JavaScript-выражения и получать результат их выполнения.

Чтобы запустить REPL, нужно открыть терминал и ввести команду node без аргументов. Вы увидите приглашение к вводу, которое обозначается символом `>`
REPL сохраняет значения переменных в памяти, пока мы не закроем оболочку. Эти команды начинаются с символа `.` (точка). Например, если мы хотим посмотреть
список всех доступных команд, можем использовать команду `.help`

`Ctrl + D` выйти из режима REPL

В целом, режим REPL может подойти для написания простых скриптов, проверки маленького кусочка кода на работоспособность или для того, чтобы вспомнить, как работает та или иная конструкция языка

## Запуск JavaScript-файлов
Для запуска фалйа используем команду: `node nameFile.js`, где **nameFile.js** имя файла скрипта.

## Написание простого веб-сервера

1. Создаем файл `index.js`
2. Импортируем модуль HTTP с помощью функции
`require()`. Эта функция возвращает объект, который содержит функции и
объекты модуля HTTP
```javascript 
const http =require('http');
```
3.Создаем объект `server` с помощью функции
`http.createServer()`. Эта функция принимает в качестве аргумента функцию обратного вызова (callback), которая будет вызываться при каждом
HTTP-запросе к серверу. Эта функция обратного вызова получает два параметра: `req` и `res`. Параметр `req` представляет объект HTTP-запроса, а
параметр `res` представляет объект HTTP-ответа.

```javascript 
const server = http.createServer((req, res)=>{
    console.log('Запрос на сервер получен')
})
```
4. Указываем порт для запуска сервера с помощью
метода `server.listen()`. Этот метод принимает два аргумента: порт и функцию обратного вызова, которая будет вызываться при успешном запуске сервера.
```javascript
const port = 3000;
server.listen(port, ()=>{
    console.log(`Сервер запущен на порту: ${port}`)
})
```

5. Запускаем скрипт командой `node index.js`

Обратите внимание, что программа не завершает свое выполнение после запуска, как обычные JS-скрипты. Программа как бы зависает в бесконечном выполнении.
Все это происходит потому, что мы запустили HTTP-сервер и он должен постоянно ожидать запроса от клиентов, не должен завершаться, пока мы не захотим это сделать руками. Такое поведение обеспечивает libUV. Чтобы завершить скрипт, нужно вызвать функцию остановки сервера `.close()`, libUV перестанет слушать порт и выполнение скрипта остановится.

## Как отправлять HTTP-ответы с помощью объекта res?

Объект res в колбеке представляет HTTP-ответ, который мы можем отправить клиенту в ответ на его HTTP-запрос. У объекта res есть различные свойства и
методы, которые позволяют нам управлять содержимым и форматом ответа.

Метод `res.writeHead()` позволяет установить заголовки ответа — метаданные, которые передаются вместе с данными ответа и содержат информацию об их
типе, размере, кодировке и других характеристиках. Метод `res.writeHead()` принимает два аргумента:
* Код состояния (status code) — число, которое указывает на результат обработки запроса сервером. Например, код 200 означает успешный ответ, а код 404 — что запрашиваемый ресурс не найден.
* Объект заголовков (headers) — объект, который содержит пары ключ-значение, где ключ — это имя заголовка, а значение — это значение заголовка. Например, `{‘Content-Type’: ‘text/html’}` означает,
что тип данных ответа — это HTML-текст.

Метод `res.end()` позволяет завершить отправку ответа. Этот метод принимает один необязательный аргумент: данные (data).
* Данные — это строка или буфер, содержащие данные ответа, которые мы хотим отправить клиенту. Например, '\<h1>Hello world!\</h1>' означает, что мы хотим отправить HTML-текст с заголовком «Hello world!». Если мы не передаем аргумент `data` в метод `res.end()`, то мы отправляем пустой ответ

В теле колбека `createServer() ` допишем две строчки:

```javascript
res.writeHead(200, {'Content-Type': 'text/html; charset=UTF-8'});
res.end('<h1>Добро пожаловать на мой сайт </h1>')
```
В первом аргументе функции `res.writeHead()` мы указываем, какой код ответа будет на этот запрос. Вторым аргументом передаем объект заголовков, где указываем
единственный заголовок `Content-Type` со значением `text/html; charset=UTF-8.` Это нужно, чтобы указать браузеру, как правильно читать тело ответа.

Метод `res.end() `завершает выполнение запроса на наш сервер и принимает в качестве аргумента строку с данными, которые мы хотим вернуть.

Теперь, если мы запустим этот код и перейдем в браузере по адресу
`http://localhost:3000/`, то мы увидим страницу с заголовком «Добро пожаловать на мой сайт!».

## Как обрабатывать разные пути запроса?

Но что, если мы хотим сделать две разные страницы? Например:
1. `http://localhost:3000/home`
2. `http://localhost:3000/about`

Когда мы получаем запрос, и запускается наш обработчик запросов, мы всегда можем узнать, какой путь в адресной строке был передан. Пути в адресной строке еще называют `роутами`.

Финальный код будет выглядеть так:

```javascript 
const http =require('http');
const server =http.createServer((req, res)=>{
    console.log('Запрос получен');
    if (req.url ===='/home'){
        res.writeHead(
            200,
            {'Content-Type':'text/html; charset=UTF-8'}
        );
        res.end('<h1>Добро пожаловать на главную страницу</h1>')
    }
    else if(req.url==='/about'){
        res.writeHead(
            200,
            {'Content-Type':'text/html; charset=UTF-8'}
        );
        res.end('<h1>Добро пожаловать на  страницу о нас </h1>')
    }
});

const port =3000;
server.listen(port, ()=>{
    console.log('Сервер запущен')
})
```
Все, что мы сделали, — добавили два условных блока.
Объект запроса `req` имеет поле `url`, которое хранит строку со значением роута, который был передан во время запроса из браузера. Таким образом мы можем
обрабатывать любые роуты, в том числе роуты вида `/home/prices`, если, например,
нужно сделать подстраницу нашей главной страницы

## Как создать страницу 404?

Код `404` говорит о том, что искомой страницы на
ресурсе не существует. 
Добавим в блок `http.createServer` еще одну проверку:

```javascript 
else{
    res.writeHead(
        404,
        {'Content-Type':'text/html; charset=UTF-8'}
    );
    res.end('<h1>Страница не найдена </h1>')
}
```
**Дополнительные материалы**

* [Официальная документация Node.js](https://nodejs.org/docs/latest/api/)
* [Документация по модулю HTTP](https://nodejs.org/api/http.html)
* [Протокол HTTP](https://developer.mozilla.org/ru/docs/Web/HTTP/Overview)

# Урок 2
* Что такое пакетный менеджер NPM?
* Инициализация проекта NPM
* Пример установки пакета
* Что такое package.json, package-lock.json
* node_modules?
* Создание и публикация собственного пакета
* Семантическое версионирование
## Что такое NPM?

NPM (Node Package Manager) – это менеджер пакетов для Node.js. Однако NPM не ограничивается только Node.js – вы можете использовать NPM для управления
пакетами для любого проекта на JavaScript.

NPM имеет множество преимуществ для разработчиков на JavaScript:

* Вы можете легко находить и использовать тысячи готовых решений для
разных задач, таких как работа с датами, строками, массивами, объектами,
HTTP запросами, базами данных и т. д.
* Вы можете контролировать версии пакетов, которые вы используете в своих
проектах, и избегать конфликтов и ошибок.
* Вы можете повышать качество и безопасность своего кода, используя пакеты
для тестирования, линтинга, форматирования, анализа и т. д.
* Вы можете делиться своими решениями с другими разработчиками и
получать обратную связь и поддержку

## Как установить NPM?

NPM является неотъемлемой частью Node.js. Поэтому, для того чтобы убедиться, что npm установлен, достаточно ввести в терминал следующую
команду `npm -v`

## Из чего состоит NPM?

NPM состоит из двух основных компонентов: **NPM registry** и **NPM CLI**.

**NPM registry**. Вы можете искать, просматривать и скачивать пакеты из npm registry с
помощью командной строки или браузера. Вы также можете опубликовать
собственные пакеты в npm registry и делиться ими с другими разработчиками. [сайт NPM] (https://www.npmjs.com/)

**NPM CLI** – это интерфейс командной строки для работы с NPM. С помощью NPM CLI
вы можете выполнять различные операции с пакетами, такие как установка,
удаление, обновление, просмотр информации и т. д.

## Как инициализировать проект npm?

Проект npm – это любая директория на вашем компьютере, которая содержит файл
`package.json`. Файл `package.json` – это специальный файл в формате JSON,
который содержит метаданные о вашем проекте, такие как имя, версия, описание,
автор, лицензия и т. д. Также в файле `package.json` указываются зависимости
вашего проекта, то есть пакеты, которые нужны для работы вашего кода.

Для того чтобы инициализировать NPM проект, вам нужно создать файл
`package.json`. Этот файл можно создать руками, но есть способ более простой,
можно запустить команду npm init в любом каталоге на вашем компьютере,
который вы хотите сделать проектом npm. Вам будет задано несколько вопросов о
вашем проекте, таких как имя, версия, описание, автор и т. д. Вы можете ответить
на них или пропустить нажатием Enter. По умолчанию будут использованы значения
из глобальных настроек npm.

После того как вы ответите на все вопросы или пропустите их, вам будет показано
содержимое файла `package.json`, который будет создан в вашем каталоге.

## Что хранится в файле package.json?
Такой JSON объект вы увидите в содержимом файла:

<image src="./images/5.jpg">

name – имя вашего пакета, которое должно быть уникальным в реестре npm.
Оно должно быть коротким, описательным и должно содержать в себе только
прописные буквы, дефисы и цифры;
* version – версия вашего пакета, которая должна следовать семантическому
версионированию. Она состоит из трёх чисел, разделённых точками:
основной версии, подверсии и номера исправления. О семантическом
версионировании мы поговорим немного позже;
* description – краткое описание вашего пакета, которое помогает
пользователям понять, что он делает и зачем он нужен. Оно должно быть
одним или двумя предложениями и не содержать HTML-тегов или
URL-адресов;
* main – эта строка указывает имя файла, который экспортирует основной
модуль вашего пакета. Это можно понимать, как точку входа в ваш проект. Об
этом поле мы более подробно поговорим немного позже;
* scripts – объект, содержащий скрипты проекта, которые могут быть
запущены с помощью команды npm run. Ключи являются названиями
скриптов, а значения – командами для запуска;
* author – объект или строка, которая указывает автора или создателя вашего
пакета. Если это объект, он может иметь три поля: name, email и url;
* license – эта строка указывает лицензию, под которой распространяется ваш
пакет. Можете пока не обращать внимания на значение лицензии, будем
использовать значение по умолчанию ISC.

 ## Пример установки пакета
Для примера установки возьмём пакет `uuid`. 

Пакет `uuid` позволяет генерировать уникальные идентификаторы. UUID – это строки из 36 символов, которые состоят из цифр и букв и имеют определённый формат

Для того чтобы установить пакет `uuid` в ваш проект, вам нужно выполнить команду
`npm install uuid`

Эта команда скачает пакет `uuid` из npm registry и добавит его в
ваш проект. Также эта команда обновит файл `package.json` и добавит пакет `uuid`
как ключ в раздел `dependencies`, а также запишет текущую версию пакета в качестве значения. Это означает, что пакет `uuid` является зависимостью вашего
проекта – то есть ваш код не может работать без него.

Обратите внимание, что версия пакета `uuid` в начале строки имеет специальный
символ `^`. Этот символ означает, что версию пакета необходимо обновлять. При выполенении команды `npm install uuid` пакет `uuid` будет обновлен, если его обновлять  не требуется нужно убрать символ `^`

Для того чтобы использовать пакет `uuid` в вашем коде, вам нужно создать новый
файл рядом с `package.json` и расширением `.js`. Например, `index.js` как указано
на пятой строке в файле package.json. После этого необходимо открыть файл в редакторе кода и вставить туда следующий
код:
```javascript
// Импортируем пакет uuid
const uuid=require('uuid');
//Генерируем uuid
const id =uuid.v4();
// Выводим сгенерированный ID 
console.log(id);
```

Теперь давайте немного разберём код. Для того чтобы использовать установленные
пакеты, необходимо в нашем скрипте получить доступ к этому коду. В Node.js можно
использовать функцию `require()`. В функцию нужно передать название пакета,
как в файле `package.json` в поле `dependencies`. 

Функция `require()` возвращает
экспортируемые методы и поля пакета `uuid`. Всё это можно записать в переменную
и использовать в коде.
В нашем примере мы записали в константу `uuid` объект с экспортируемыми
модулями и полями пакета `uuid`. Далее, для генерации уникального
идентификатора, мы вызвали функцию `.v4()` и получили результат в виде строки.
Для того чтобы запустить код, можно использовать Node.js. Для этого в консоли
выполните команду `node index.js`

после установки пакета `uuid`
в директории вашего проекта автоматически создалась директория `node_modules` и
файл `package-lock.json`
## Что такое node_modules и как он устроен?

**node_modules** – это каталог в вашем проекте npm, в котором хранятся все
установленные пакеты и их зависимости. Когда вы устанавливаете пакет с
помощью NPM, он скачивается из `npm registry` и размещается в каталоге
`node_modules`. Также в каталоге `node_modules` размещаются все пакеты, от которых
зависит установленный пакет.

Структура папки `node_modules` зависит от того, какая версия NPM используется для
установки пакетов. До третьей версии NPM использовал древовидную структуру, в
которой каждый пакет имел свою подпапку `node_modules` со своими
зависимостями. Это приводило к дублированию и избыточности файлов, а также к
проблемам с длиной пути файлов на некоторых операционных системах.

<image src="./images/6.jpg">

Начиная с третьей версии NPM стал использовать плоскую структуру, в которой все
зависимости устанавливаются на одном уровне в папке `node_modules`. Это
уменьшило количество файлов и длину пути файлов, а также упростило
разрешение конфликтов версий.

<image src="./images/7.jpg">

*Начиная с третьей версии NPM, если два пакета требуют разные версии
одной и той же зависимости, то NPM создаст подпапку node_modules для
одного из пакетов и установит туда нужную версию зависимости*

Каталог node_modules может быть очень большим и содержать много пакетов и
файлов, поэтому его не рекомендуется добавлять в систему контроля версий.

## Установка зависимостей проекта
чтобы запустить проект, необходимо установить все зависимости.
Для этого нужно выполнить две команды: `npm install` или `npm ci`
## Отличие npm install от npm ci

**npm install** (без указания конкретного пакета) создаёт директорию `node_modules` и
скачивает туда все зависимости, указанные в `package.json`, а также создаст файл
`package-lock.json`. Если `node_modules` и `package-lock.json` уже существуют, `npm
install` проверит, все ли пакеты, которые есть в `package.json`, есть в `node_modules` и
установит недостающие пакеты. Также важно понимать, что `npm install` обновит
пакеты, у которых в версии есть специальный символ `^` до более актуальных и
обновит информацию о версиях в `package-lock.json`. Если специальный символ `^` не
указан в версии пакета, то пакет обновлён не будет.

**npm ci** (clean install) так же как и `npm install`, создаст директорию `node_modules`,
если она отсутствует, но при этом версии пакетов будет сверять с файлом
`package-lock.json`, при этом версии пакетов npm ci не обновляет. Если директория
`node_modules` уже существует, то npm ci удалит её и создаст, заново скачав туда все
необходимые зависимости. Это более безопасный способ установки зависимостей,
так как иногда автоматическое обновление пакетов с помощью `npm install` может
привести к поломке вашего кода, если разработчики пакета допустили ошибку в
новой версии пакета, хотя такое происходит крайне редко.

## Удаление пакетов
NPM позволяет удалить установленный пакет, если он вам больше не нужен. Для
этого существует команда `npm uninstall <имя_пакета>`.

Эта команда удалит все файлы, связанные с пакетом, из `node_modules`, а также
удалит строку с названием и версией пакета из `package.json`.

Также вы можете удалить пакет, удалив в `package.json` строку с его упоминанием и
набрав в консоли команду `npm ci` или `npm install`. Эти команды удаляют из
`node_modules` любые пакеты, которые не упоминаются в `node_modules`.

## Что такое package-lock.json?

**package-lock.json**– это специальный файл, который создаётся и обновляется
автоматически при установке или обновлении пакетов npm. Этот файл содержит
точную информацию обо всех установленных пакетах в вашем проекте и их
зависимостях, включая номера версий, хеши и пути к файлам.

**package-lock.json** нужен, для того чтобы гарантировать, что вы и другие
разработчики, работающие с вашим проектом, используете одинаковые версии
пакетов и зависимостей. Это помогает избежать проблем с несовместимостью или
ошибками при запуске или развёртывании вашего проекта.

**package-lock.json** гарантирует, что если другой разработчик скачает ваш проект с Git
и установит зависимости с помощью команды npm ci, то все версии пакетов будут
такими же, какие и у вас.
Вы не должны редактировать файл `package-lock.json` вручную или удалять его
из вашего проекта. Вы должны добавить его в систему контроля версий, чтобы
сохранять его историю и синхронизировать его с другими разработчиками.

[официальная документация package.json](https://docs.npmjs.com/cli/v8/configuring-npm/package-lock-json)
## Что такое dependencies и devDependencies и в чём их различие?

 Ранее мы установили пакет `uuid`, и в `package.json` он добавился в объект `dependencies`. Но существует другой вариант установки пакета. Когда вы устанавливаете пакеты в ваш проект с помощью NPM, вы можете указать тип зависимости для каждого пакета: `dependencies` или `devDependencies`.

**dependencies** – это зависимости, которые необходимы для работы вашего кода в
продакшене – то есть когда вы запускаете или разворачиваете свой проект на
реальном сервере или клиенте. Например, если вы создаёте веб-приложение на
React, то React является зависимостью типа `dependencies`.

**devDependencies** – это зависимости, которые необходимы только для разработки
вашего кода – то есть когда вы пишете, тестируете или отлаживаете свой код на
локальном компьютере. Например, если вы используете Jest для тестирования
своего кода, то Jest является зависимостью типа `devDependencies`.

Разделение зависимостей на два типа помогает оптимизировать размер и скорость
вашего проекта в продакшене, так как вам не нужно устанавливать и загружать
лишние пакеты, которые не используются в продакшн среде.

Для того чтобы установить пакет как зависимость типа dependencies, вы должны
использовать команду `npm install <package-name>` без дополнительных
флагов. Для того чтобы установить пакет как зависимость типа devDependencies, вы
можете использовать команду `npm install <package-name> --save-dev` или
`npm install <package-name> -D`.

## Что такое скрипты NPM?

Вы можете заметить, что в `package.json` есть поле `scripts`. Сюда вы можете помещать различные скрипты, которые вам помогут в разработке.

Скрипты NPM – это способ автоматизировать различные задачи, связанные с вашим
проектом. Вы можете запускать скрипты npm с помощью команды `npm run <script-name>` в командной строке, где `<script-name>` – это название вашего скрипта. Названием скрипта является само поле в объекте `scripts`.

Скрипты npm могут выполнять различные действия, такие как компиляция, форматирование, проверка, тестирование, сборка или публикация вашего кода.

Также вы могли заметить, что в `scripts` есть поле `test` – это тестовый скрипт,
который создаётся по умолчанию в проекте npm. Если запустите этот скрипт `npm run test`, то увидите сообщение в консоли *Error: no test specified*. Базово
этот скрипт нужен для указания команды на запуск тестов. 

## Экспорт из модулей
Экспорт функций и переменных в node.js позволяет использовать их в других
файлах или модулях, позволяя повторно использовать код и упрощая отладку и
поддержку приложения.

Для экспорта функций и переменных в node.js нужно использовать объект
`module.exports`, который является свойством глобального объекта `module`. Этот
объект содержит всё то, что будет доступно для импорта в других файлах или
модулях.

Cоздадим файл в нашем проекте и назовём его math.js добавим туда две функции: `add()` – функция сложения чисел и `subtract()`
```javascript
//math.js
function add(a,b){
    return a + b;
}
function subtract(a,b){
    return a - b;
}
module.exports= {add, subtract}
```

Для импорта функций и переменных в `node.js` нужно использовать уже знакомую
вам функцию `require()`. Она принимает путь к файлу или модулю, из которого
нужно импортировать. Эта функция возвращает объект с импортированными
данными, который можно сохранить в переменной и использовать для вызова
функций или доступа к переменным.

Например, если мы хотим импортировать функции `add` и `subtract` из файла
`math.js` в файл `index.js`, мы можем сделать следующее:
```javascript
//index.js
const math =require('./math')

const result = math.add(3,5);
console.log(result)

const result = math.subtract(3,5);
console.log(result)
```
Обратите внимание на два вызова функции `require()`.
В первом случае `require('uuid')` нет необходимости указывать
относительность пути, то есть добавлять `./` или `../` , так как это
установленный npm пакет.

Во втором случае также можно не указывать относительность пути `./` ,
если файл находится в той же директории, в которой мы импортируем модуль, но следует помнить, что если файл будет находиться в другой директории, например, `libs` , то нам нужно будет вызвать require следующим образом: `require(’./libs/math.js’)`. Для того чтобы не путать локальные файлы с установленными пакетами, рекомендуется всегда указывать относительность пути, как в примере с кодом:
`require(’./math’);`

## Как создать собственный пакет?
Для этого нужно зайти на [официальный сайт NPM](https://www.npmjs.com/) и в строке поиска ввести любое название пакета, которое вам необходимо. Например, если ввести слово `math`, то мы увидим ряд пакетов, которые содержат в названии, в описании, либо в тегах слово `math`. Нужно придумать название пакета которое свободно.

Теперь давайте создадим новый `npm` проект. Инициализируем проект `npm init -y`

Создадим файл `math.js` и заполним его следующим кодом:
```javascript
//math.js
function add(a,b){
    return a + b;
}
function subtract(a,b){
    return a - b;
}
module.exports= {add, subtract}
```
Также необходимо рядом с `package.json` создать файл `README.md` с описанием
проекта. Это описание будет использоваться на сайте `npm`.

Теперь необходимо подготовить файл package.json

Нужно придумать название нашего пакета и написать в поле `name`. Оно
должно быть уникально в рамках `npm registry`. Проверить уникальность
достаточно просто: нужно зайти на официальный сайт NPM и в поисковой
строке поискать по названию, которое вы хотите дать своему пакету, другие
пакеты с таким же названием. Если поиск не дал результатов – это означает,
что имя не занято и его можно использовать.
* Также нужно добавить описание нашего пакета в поле `description`
* И ещё не забываем указать себя в качестве автора пакета в поле `author`
* Теперь обратите внимание на поле `main` . В этом поле хранится путь до
файла, который будет использован, как файл для импорта.  То есть пользователи, скачавшие ваш пакет, когда в `require()` укажут название вашего пакета, получат результатом выполнения функции `require()` значение, которое экспортируется из модуля. В нашем случае необходимо заменить `index.js` на `math.js`

Теперь публикуем! Для этого необходимо проделать некоторые действия:
* Создайте аккаунт на [NPM](https://www.npmjs.com/) или войдите в свой
существующий аккаунт.
* Подтвердите свой адрес электронной почты.
* В терминале авторизуйтесь в `npm registry` с помощью команды `npm login`.
Эта команда отправит вас в браузер и попросит ввести код из письма на
почте.
* Опубликуйте ваш пакет в` npm registry` с помощью команды `npm publish`
* Проверьте, что ваш пакет появился на сайте [NPM](https://www.npmjs.com/) и
доступен для установки и использования.

Теперь можно устанавливать этот пакет и переиспользовать его код в любом
проекте! Достаточно установить его `npm install name_your_package`.

## Что такое семантическое версионирование?

Давайте теперь разберёмся, как работают версии пакетов в проекте. Для
версионирования пакетов используется семантическое версионирование.

Семантическое версионирование – это система правил и соглашений для
присвоения номеров версий пакетам. Семантическое версионирование помогает
разработчикам понимать, какие изменения произошли в пакете при обновлении его
версии, и как эти изменения могут повлиять на совместимость с другими пакетами.

Семантическое версионирование использует следующий формат для номеров
версий: `major.minor.patch`.
Где:
* **major** – это мажорная версия, которая увеличивается, когда в пакете
происходят серьёзные изменения, которые ломают обратную совместимость
с предыдущими версиями. Например, если в пакете изменяется API,
удаляются функции или меняются зависимости.
* **minor** – это минорная версия, которая увеличивается, когда в пакете
добавляются новые функции или улучшения, которые не ломают обратную
совместимость с предыдущими версиями. Например, если в пакете
добавляются новые опции, параметры или методы.
* **patch** – это патч-версия, которая увеличивается, когда в пакете исправляются
ошибки или баги, которые не влияют на функциональность или
совместимость с предыдущими версиями. Например, если в пакете
исправляются опечатки, улучшается производительность или безопасность.

При изменении более старшей версии, более младшие обнуляются. Например, если
у нас есть версия `2.5.2`и увеличивается минорная версия, то получится `2.6.0`, то
есть патч версия обнулилась.

## Какие ещё есть команды для npm cli?

* `npm help` или `npm h` – выводит справочную информацию о командах `npm cli`;
* `npm uninstall <package-name>` или `npm un <package-name>` – удаляет
пакет из вашего проекта и из файла `package.json`;
* `npm list` или `npm ls` – выводит список всех установленных пакетов в
вашем проекте и их версии;
* `npm view <package-name>` или `npm v <package-name>` – выводит
информацию о пакете из `npm registry`, такую как имя, описание, версия,
лицензия, зависимости и т. д.;
* `npm search <keyword>` или `npm s <keyword>` – ищет пакеты в `npm registry`
по ключевому слову и выводит их названия и описания.
* `npm repo <package-name>` выводит ссылку на репозиторий git проекта

Полный список команд можно посмотреть здесь [NPM](https://docs.npmjs.com/cli/v7/commands)

**Дополнительные материалы**

* Официальная документация [NPM](https://docs.npmjs.com/), где вы найдете подробные инструкции и примеры по использованию NPM и его команд.
* Полное описание правил семантического версионирования https://semver.org/lang/ru/


Словарь терминов
* **Пакет** – это набор файлов кода, который можно установить и использовать в
своём проекте. Пакет может содержать один или несколько модулей
JavaScript, а также другие ресурсы, такие как документация, тесты,
конфигурации и т. д. Пакеты могут быть созданы вами или другими
разработчиками и опубликованы в npm registry.
* **Модуль** – это отдельный файл кода JavaScript, который экспортирует одну
или несколько функций, объектов или переменных. Модуль может быть
импортирован в другой модуль с помощью оператора require или import.
Модули позволяют разбивать код на логические части и повторно
использовать его в разных местах.
* **NPM registry** – это онлайн-репозиторий, в котором хранятся все пакеты,
опубликованные с помощью NPM. Вы можете искать, просматривать и
скачивать пакеты из npm registry с помощью командной строки или браузера.
Вы также можете опубликовать собственные пакеты в npm registry и делиться
ими с другими разработчиками.
* **NPM CLI** – это интерфейс командной строки для работы с NPM. С помощью
NPM CLI вы можете выполнять различные операции с пакетами, такие как
установка, удаление, обновление, просмотр информации и т. д.
* **Проект npm** – это любой каталог на вашем компьютере, который содержит
файл package.json. Файл package.json – это специальный файл в
формате JSON, который содержит метаданные о вашем проекте, такие как
имя, версия, описание, автор, лицензия и т. д. Также в файле package.json
указываются зависимости вашего проекта – то есть пакеты, которые нужны
для работы вашего кода.
* **Семантическое версионирование** – это система правил и соглашений для
присвоения номеров версий пакетам. Семантическое версионирование
помогает разработчикам понимать, какие изменения произошли в пакете при
обновлении его версии, и как эти изменения могут повлиять на
совместимость с другими пакетами.

# Урок 3. Модули и фреймворк Express (WIP)

* Модули в Node.js
* Обзор встроенных модулей
* Глобальные объекты и функции
* Работа с модулями
* Обзор фреймворка express
* Создание http сервера с помощью express

## Модули
Для того чтобы разделить проект Node.js на несколько файлов и переиспользовать функции и переменные необходимо понимать, каким образом обеспечивается экспорт и импорт данных в модулях.

Существует три вида модулей:

* Встроенные модули – эти модули являются частью Node.js. Вы уже знакомы с
одним из таких модулей – это модуль http.
* Модули NPM – эти модули можно установить с помощью NPM. С такими
модулями вы тоже познакомились во второй лекции.
* Пользовательские модули – это модули, которые вы создаёте сами. С этим
видом модулей мы познакомимся более подробно в этой лекции.

## Экспорт данных из модуля

Любой модуль может экспортировать какие-либо данные, чтобы их можно было
переиспользовать в другом модуле. Если представить модуль, как обычную
функцию, то экспорт из модуля – это аналог оператора return. То есть модуль
возвращает какие-то значения во время импорта этого модуля. В Node.js экспорт из модуля реализуется через уже знакомый вам глобальный объект `module.exports`

Из модуля можно экспортировать любые типы данных: функции, строки, числа,
массивы и объекты. По умолчанию `module.exports`– это пустой объект. 

**Необходимо помнить одно правило** – экспорт должен происходить
незамедлительно! Давайте разберём это правило на примере:
```javascript
setTimeout(()=>{
    const someVar =10;
    module.exports = { someVar };
}, 0)
```

`module.exports` определён в колбеке `setTimeout`. Так как `setTimeout` асинхронная функция, то колбек выполнится в будущем. Это означает, что как только мы импортируем модуль с таким кодом, мы не получим в `module.exports` нужные данные, они определятся чуть позже. Именно по этому нельзя использовать `module.exports` в асинхронных функциях.

Вот ещё пример, когда экспорт не будет работать:

```javascript
function exportInFunction () {
    const someVar =10;
    module.exports = { exportInFunction };
}
```

Тут в целом понятно, почему не получится экспортировать данные, так как функция
не вызывается. Если функцию вызвать, то данные будут экспортированы, но так использовать `module.exports` не рекомендуется, так как это будет вас путать.

Хорошим способом экспортировать данные из модуля будет определение
`module.exports` в конце скрипта.

## Импорт модулей

Импортировать модули можно с помощью функции `require().`

Функция `require() `– это глобальная функция Node.js, которая
используется для загрузки и кэширования модулей. Она принимает один
аргумент – `имя` или `путь к файлу модуля`, который нужно загрузить, и
возвращает экспортированные свойства из этого модуля.

Функция `require()` может принять в качестве аргумента имя модуля, если это
глобальный модуль или модуль NPM, либо путь к модулю, если это
пользовательский модуль.

Функция `require() `работает следующим образом:
1. Функция `require()` сначала ищет встроенные модули по переданному имени
модуля.
2. Если глобального модуля с указанным именем нет, то `require()` ищет
установленные модули с помощью NPM.
3. И наконец, если нет ни глобального, ни NPM модулей, или указан путь к
модулю, то ищет среди пользовательских модулей.

Это упрощенный алгоритм работы функции. Если хотите ознакомиться более
подробно с алгоритмом, можете обратиться к [официальной документации](https://nodejs.org/api/modules.html#all-together).


## Пользовательские модули
Чтобы импортировать пользовательский модуль, достаточно в аргумент функции `require()` указать путь к файлу.

Обратите внимание, что путь к модулю указывается относительно модуля, в
котором мы импортируем. Также можно не указывать расширение файла модуля,
`require()` автоматически подставит расширение, если его нет.

Ещё `require()` позволяет импортировать директорию, вместо файла. Для этого
необходимо указать путь к директории и в директории обязательно должен
находиться файл `index.js`

Пример того, как можно импортировать директорию. В директории
`myLib` находится файл `index.js`, который экспортирует объект со свойством hello.
Импортируется эта директория в файле `main.js` и в `require()` указывается путь до
директории импортируемого модуля.

```javascript
// ./mylib/index.js
    module.exports = { hello: 'hello' }
// main.js
    const myLib = require('./mylyb');
```

Такой импорт может пригодиться, когда вы реализуете, к примеру, библиотеку,
которая разбита на несколько файлов. Для того чтобы не думать при импорте, какой
конкретно файл нужно указывать, вы просто можете создать директорию и
определить в ней файл index.js, который будет использоваться для импорта по
умолчанию и при импорте указывать просто путь к директории.

## Импорт по цепочке
Важно понимать, что импортируемые модули могут также импортировать в себя
другие модули.

Первый модуль в этой цепочке – это модуль `baz`, который ничего не импортирует, но
экспортирует данные
```javascript
// baz.js
    module.exports = 'Hello from Baz!'
```
Второй модуль – это модуль `foo`, который импортируем модуль baz и экспортирует
собственные данные.
```javascript
// foo.js
    const baz = require('./baz');
    console.log(baz)
    module.exports = 'Hello from Foo!'
```

И третий модуль – это модуль index, который импортирует модуль `foo`
```javascript
// index..js
    const baz = require('./foo');
    console.log(foo)
```
## Циклические зависимости
Иногда могут возникнуть ситуации, когда цепочка зависимостей начинается и
заканчивается на одном и том же файле. Это называется циклические зависимости.

<image src="./images/8.jpg">

В данном примере `index.js` импортирует `foo.js`. `foo.js`, в свою очередь, импортирует `baz.js`, а `baz.js` импортирует `index.js`. То есть цепочка импортов начинается и заканчивается на одном и том же файле – `index.js`.

Таких зависимостей стоит избегать, так как они ломают работу кода.
## Глобальные объекты и функции

Для удобства некоторая функциональность Node.js реализована не в отдельном
модуле, а представлена глобально. Что это значит? Глобальные объекты и функции Node.js – это объекты и функции, которые доступны во всех модулях без необходимости их подключения с помощью `require()`. Например, `console`, `process` и `__dirname` и т. д. Они являются частью среды исполнения Node.js и определены как глобальные объекты и функции для удобства.

Для использования глобальных объектов и функций Node.js достаточно просто
обратиться к ним по имени.
## Объект global
В `Node.js` существует глобальный объект `global`. В этом объекте хранятся различные
объекты и функции, такие как `console`, `Math`, `setTimeout` и т. д.
## Объект process
`process` содержит в себе набор функций и свойств для работы с операционной системой и запущенным процессом Node.js.
```javascript
console.log(process.version) // Версия Node.js
console.log(process.arch) // Архитектура процессора
console.log(process.pid) // id (идентификатор) текущего процесса. 
console.log(process.cwd) // Директория откуда запущен скрипт
console.log('Process Platform', process.platform); // Платформа win32\win86
```
Подробней о process в [документации](https://nodejs.org/api/process.html)

## Свойства `__dirname` и `__filename`
Чтобы определить путь в файловой системе к этому же скрипту,
можно воспользоваться двумя свойствами: `__dirname` и `__filename`

```javascript
console.log(__dirname) // Путь к файлу 
console.log(__filename) // Путь к директории где находится файл 
```

**Обратите внимание** на разницу между `process.cwd()` и `__dirname`. С первого взгляда кажется, что они делают одно и то же, но на самом деле между ними есть
существенное различие: `process.cwd()` возвращает путь к директории, откуда был
запущен скрипт, а `__dirname` возвращает директорию, где скрипт хранится.

Полный список глобальных объектов и функций Node.js можно найти в [официальной документации](https://nodejs.org/api/globals.html).

## Встроенные модули Node.js
Встроенные модули устанавливаются вместе с Node.js и их не нужно устанавливать отдельно.

Встроенные модули предоставляют различные возможности для работы с файлами, сетью, операционной системой, потоками, событиями, криптографией и другими аспектами программирования на Node.js.

### Модуль `fs`
Модуль fs (file system) предоставляет функции для работы с файловой системой. С
его помощью можно читать, записывать, удалять и перемещать файлы и
директории. После подключения модуля мы можем использовать его методы для
работы с файлами.

### Модуль `fs.readFile()`
Для чтения файлов существует метод `fs.readFile()`. Он позволяет получить
содержимое любого файла:
```javascript
// Подключаем модуль
const fs =require('fs');
// Читаем файл hello.txt
fs.readFile('./hello.txt', 'utf-8', (err, data)=>{
    if(err){
        // Если произошла ошибка выводим её
        console.error(err)
    }else{
        // Если нет ошибки выводим содержимое файла
        console.log(data)
    }
})
```
Метод принимает три аргумента:
* путь к файлу, который хотим прочитать;
* кодировку файла (опционально);
* функцию обратного вызова (callback), которая будет вызвана после чтения файла.

Функция обратного вызова в третьем аргументе имеет два аргумента:
* объект ошибки (если произошла ошибка при чтении файла);
* данные файла (если чтение файла успешно).

Метод `fs.readFile()` является асинхронным, то есть он не блокирует выполнение
остального кода до тех пор, пока не прочитает файл. Вместо этого он передаёт
результат чтения файла в функцию обратного вызова, которая будет вызвана
позже.

### Метод `.writeFile()`
Этот метод полностью перезаписывает указанный файл

Метод принимает три аргумента:
* путь к файлу, в который нужно записать данные;
* строка с данными, которые хотим записать;
* функция обратного вызова, которая запустится, когда файл будет записан.

Функция обратного вызова в третьем аргументе принимает один аргумент:
* объект ошибки, который будет инициализирован в случае ошибки записи.

```javascript
// Подключаем модуль
const fs =require('fs');
// Pfgbc файл hello.txt
fs.writeFile('./path/to/file', 'Some text data', (err)=>{
    if(err){
        // Если произошла ошибка выводим её
        console.error(err)
    }else{
        // Если нет ошибки выводим содержимое файла
        console.log('The file was saved')
    }
})
```

### Метод `fs.appendFile()`
Если хочется не перезаписывать файл, а добавлять в файл данные для этого существует метод `fs.appendFile()`.

Этот метод работает очень похожим образом как метод `.writeFile()`

## Синхронные и асинхронные 

Модуль `fs` помимо асинхронных методов имеет также синхронные методы.

Асинхронные методы имеют преимущество в том, что они не замедляют работу
приложения и позволяет обрабатывать множество файлов одновременно. Однако,
это также означает, что порядок выполнения кода может быть неочевидным.

Синхронные же методы блокируют выполнение скрипта до тех пор, пока работа с
файлом не закончится и при этом не требуют определения колбека в третьем
аргументе. Также методы называются по-другому и имеют постфикс Sync.
Например, синхронный аналог метода `fs.readFile()` является `fs.readFileSync()`, а аналогом метода `fs.appendFile()` является `fs.appendFileSync()`.

```javascript
// Подключаем модуль
const fs =require('fs');

try{
    // Если нет ошибки выводим содержимое файла
    const result =fs.readFileSync(__filename, 'utf-8');
    console.log(result)
}
catch(err){
    // Если произошла ошибка выводим её
    console.error(err)
}
```
Как видите, результат чтения файла возвращается функцией `fs.readFileSync()`, а
любые ошибки, которые могут возникнуть во время работы с файлом, необходимо
обрабатывать с помощью `try {} catch {}`

В целом синхронные методы рекомендуется использовать только в тех случаях,
когда вы уверены, что они не повлияют на работу вашего приложения. Например,
если вы делаете `http сервер`, который постоянно слушает входящие запросы, не
стоит использовать синхронные функции, так как они остановят выполнение
вашего кода и ваш сервер не сможет обработать входящие запросы, пока работа с
файлом не будет закончена.

Синхронные методы часто используют при старте приложения, например, чтобы
один раз прочитать какие-нибудь конфигурационные файлы. Или когда реализуют
простой скрипт, который не требует высокой скорости работы. Это допустимые
сценарии использования. Во всех остальных случаях следует воздержаться от
использования синхронных методов.

## Модуль `path`
Модуль path предоставляет ряд методов для работы с путями в файловой системе.
* Метод `path.join()` позволяет объединить две части путей в один путь. Метод
вернёт строку с результатом объединения.

```javascript
const path =require('path');
console.log(path.join('/User/Student', 'Desctop/index.js'))
// Вернет строку '/User/Student/Desctop/index.js'
```
* Метод `path.parse()` возвращает объект пути, в котором хранятся составляющие пути.

```javascript
const path =require('path');
console.log(path.parse('/User/Student/Desctop/index.js'))
// Вернет  следующий объект: 
{
    root:"/",
    dir:"User/Student/Desctop",
    base:"index.js",
    ext: ".js",
    name:"index"
}
```

* Метод `path.dirname()` возвращает путь к директории, исключив название
файла из пути.
```javascript
const path =require('path');
console.log(path.dirname('/User/Student/Desctop/index.js'))
// Вернет строку '/User/Student/Desctop/'
```

* Метод `path.extname()` возвращает расширение файла, который указан в
передаваемом пути
```javascript
const path =require('path');
console.log(path.join('/User/Student/Desctop/index.js'))
// Вернет строку '.js'
```

### Модуль `os`
Модуль `OS` позволяет получить информацию об операционной системе
```javascript
const os =require('os');
// Вернет массив с информацией о ядрах процессора
console.log(os.cpus())
//Вернет информацию об архитектруе процессора
console.log(os.arch())
//Вернет информацию о свободной оперативной памяти
console.log(os.freemem())
//Вернет информацию об общем кол-ве оперативной памяти
console.log(os.totalmem())
// Вернет строку '.js'
```

## Какие ещё модули существуют?

* **`url `**– позволяет работать с URL адресами и их компонентами;
* **`crypto`** – позволяет работать с криптографией. Содержит в себе различные
криптографические функции;
* **`stream`** – позволяет управлять большими потоками данных.

Модули которые есть в Node.js [тут](https://nodejs.org/dist/latest-v18.x/docs/api/)

## Введение в express

Для реализации веб-сервера, конечно же, можно использовать встроенный модуль
`http`, но он довольно низкоуровневый и в случае, если вы сделаете действительно
большой и сложный веб-сервер, код будет читать довольно сложно. В связи с этим
существует множество сторонних библиотек и фреймворков, которые помогают
упростить код и предоставить более высокий уровень абстракции для реализации
`http` сервера. Одним из таких фреймворков – это `express`.

Express – это фреймворк для Node.js, который предоставляет набор функций и
инструментов для создания веб-приложений и API.

Express позволяет легко и быстро создавать веб-сервер, обрабатывать
HTTP-запросы, маршрутизировать URL, работать с промежуточными обработчиками
(middleware), использовать шаблонизаторы для генерации HTML-страниц,
настраивать параметры и переменные окружения, обрабатывать ошибки и многое
другое. Express является минималистичным и гибким фреймворком, который не
навязывает определённой структуры или способа организации кода, а позволяет
разработчику самостоятельно выбирать нужные модули и библиотеки.

## Отличие Express от встроенного пакета http
`Express` построен на основе встроенного пакета `http`, который предоставляет
низкоуровневые функции для работы с HTTP-протоколом. Express расширяет и
упрощает возможности пакета `http`, добавляя высокоуровневые абстракции и
удобные методы для создания веб-приложений. Например, с помощью `Express`
можно легко создать `http` сервер таким образом:

```javascript
const express =require('express');
// Создаем объект приложения
const app =express();
// Создаем обработчик GET-запроса по корневому пути
app.get('/', function (req, res){
        res.send('answer to servet')// отправляем ответ серверу
});
app.listen(3000)// запускаем сервер на порту 3000
```


Express позволяет:
* Использовать методы `app.get()`, `app.post()` и т. д. для определения
обработчиков запросов по разным HTTP-методам и URL-путям.
* Использовать метод `res.send()` для отправки ответа с автоматическим
определением типа контента и кодировки.
* Использовать метод `app.listen()` для запуска сервера на указанном порту.

Кроме того, `Express` предоставляет множество других возможностей, таких как:

* Поддержка параметров в `URL-путях`. Например, если вы хотите определить
часть URL, как изменяемую часть.
* Поддержка статических файлов и шаблонизаторов.
* Поддержка промежуточных обработчиков для выполнения различных задач перед или после обработки запроса.
* Поддержка маршрутизаторов для организации обработчиков по группам или модулям.
* Поддержка обработки ошибок и специальных ответов (например, 404).
## Установка и запуск Express
Для того чтобы использовать Express в своём проекте, необходимо установить его
как зависимость с помощью NPM. Для этого нужно выполнить следующую команду
в терминале: `npm install express`.

Эта команда установит Express в папку node_modules и добавит его в файл
package.json в раздел dependencies.

```javascript
const express =require('express');
const app =express();
```
Экземпляр приложения `app` представляет собой объект, который содержит методы
для настройки и запуска сервера, а также для определения обработчиков запросов.

Далее необходимо запустить сервер с помощью метода `app.listen()`. Для запуска,
необходимо передать в аргумент метода `.listen()` номер порта, на котором будет
слушать сервер.

```javascript
const express =require('express');
const app =express();
app.listen(3000);
```
Теперь можно определять HTTP обработчики. Это делается вызовом методов `.get()`,
`.post()`, `.put()`, `.delete()` и т. д. на объекте `app`.

```javascript
const express =require('express');
const app =express();
app.get('/', function (req, res){
        res.send('<h1>answer to servet</h1>')
});
app.listen(3000)
```
Определять обработчики можно как до вызова метода `.listen()`, так и после, но лучше определять обработчики до старта сервера, чтобы избежать случаев, когда сервер запущен, но обработчики ещё не инициализировались

Express позволяет определить несколько обработчиков. Например, мы можем
определить обработчик для роута `/about`:
```javascript
const express =require('express');
const app =express();
app.get('/', function (req, res){
        res.send('<h1>answer to servet</h1>')
});
app.get('/about', function (req, res){
        res.send('<h1>Abot page</h1>')
})
app.listen(3000)
```
## Объекты req и res
Подробнее разберём колбек в третьем аргументе. Этот колбек
выполняется, когда приходит запрос и в аргументах этого колбека мы можем
получить два объекта.

Первый объект – это объект `req` (request). Этот объект хранит в себе информацию о запросе, такую как: url запроса, метод запроса, информация о клиенте и т. д.

Второй объект – это объект `res` (response). Этот объект хранит в себе свойства и
методы, которые позволяют работать с ответом. Например, метод `.send()` позволяет
завершить запрос и указать данные, которые необходимо вернуть клиенту, а метод
`.status()` позволяет указать `http` статус ответа.
## Промежуточные обработчики
В `Express` существует концепция промежуточных обработчиков или `middleware`.
Такие обработчики нужны, для того чтобы задавать дополнительную логику для
основных обработчиков.

<image src="./images/9.jpg">

Существует два вида промежуточных обработчиков: глобальные и локальные.
* Глобальные промежуточные обработчики не привязаны к конкретному роуту
и отрабатывают для группы роутов или абсолютно для всех роутов.
* Локальные промежуточные обработчики определяются для конкретного
роута.

## Глобальные промежуточные обработчики
```javascript
const express =require('express');
const app =express();
// Логируем факт запроса
app.use((req, res, next)=>{
    console.log('Поступил запрос', req.method, req.url);
    next();
})
app.get('/', function (req, res){
        res.send('<h1>answer to servet</h1>')
});
app.get('/about', function (req, res){
        res.send('<h1>Abot page</h1>')
})
app.listen(3000)
```
Допустим, мы хотим логировать любой входящий запрос. Чтобы не писать логику
логирования в каждом роуте, можно добавить глобальный промежуточный
обработчик до определения всех роутов. Реализуется это с помощью метода
`app.use()` На шестой строке вы можете увидеть, что метод принимает один
единственный аргумент в виде колбека, который очень похож на колбек в обычном
обработчике. В первом аргументе можно получить объект запроса, во втором –
объект ответа, а третий аргумент хранит в себе функцию `next()`.

Функция `next() `необходима для того чтобы продолжить вызов следующих
обработчиков. Если функцию `next() `не вызвать, то обработчики роутов не
запустятся и запрос зависнет. То есть в промежуточном обработчике мы должны
сообщить `express-у`, когда стоит запускать следующие обработчики.

**Важно понимать, что порядок определения обработчиков очень важен!** 

Например, если в примере выше мы определим промежуточный
обработчик после основных обработчиков роутов, то промежуточный
обработчик никогда не выполнится.

Но существуют ситуации, когда промежуточный обработчик, определённый после
основных обработчиков роутов, будет работать. Это может произойти в том случае,
если не был найден нужный обработчик роута.

```javascript
const express =require('express');
const app =express();

app.get('/', function (req, res){
        res.send('<h1>answer to servet</h1>')
});

app.use((req, res)=>{
    res.status(404)
    console.log('Поступил запрос', req.method, req.url);
    res.send('<h1>Страница не найдена</h1>')
})
app.listen(3000);
```
В коде выше определён один единственный обработчик для
корневого роута. После определения этого обработчика, определён промежуточный обработчик, в котором устанавливается статус ответа `res.status(404);` и отправляется HTML клиенту. Если запустить этот код и попробовать обратиться к неопределённому роуту, например, к `/about`, то запуститься промежуточный обработчик `app.use()`. Это происходит потому, что `express` ищет обработчик для переданного `url`, и если такого обработчика нет, то запускается следующий глобальный обработчик по порядку. В нашем случае этот обработчик отправляет информацию клиенту о том, что страница не найдена.

Вот так просто в `express` реализовать обработку несуществующих роутов, для этого
достаточно определить глобальный обработчик после всех основных.

## Локальные промежуточные обработчики
```javascript
const express =require('express');
const app =express();

function logRequest(req, res, next){
    console.log('Поступил запрос', req.method, req.url);
    next();
}
app.get('/',  logRequest, (req, res){
        res.send('<h1>answer to server</h1>')
});
app.listen(3000);
```
В примере выше  определена функция `logRequest` промежуточного
обработчика, которая логирует запрос. Далее обратите внимание определённый выше промежуточный обработчик, передан во второй аргумент, а в третьем уже определён основной обработчик. На самом деле `express`, при вызове методов определения обработчиков, принимает любое количество аргументов. То есть начиная со второго аргумента, `express` вызывает все указанные далее в аргументах обработчики по порядку.


```javascript
const express =require('express');
const app =express();

function logRequest(req, res, next){
    console.log('Поступил запрос', req.method, req.url);
    next();
}
app.get('/',  logRequest, logRequest, logRequest, (req, res){
        res.send('<h1>answer to server</h1>')
});
app.listen(3000);
```
В примере выше переданы друг за другом три промежуточных обработчика, и
только потом определён основной обработчик роута. Запустив этот код, при
запросе на ваш роут, вы получите три сообщения в консоли.

Также можно определить промежуточный обработчик прямо в вызове метода, как и
основной обработчик:
```javascript
const express =require('express');
const app =express();


app.get('/', 
    (req, res, next) {
        console.log('Поступил запрос', req.method, req.url);
        next();
    },
    (req, res){
        res.send('<h1>answer to server</h1>')
    }
);
app.listen(3000);
```

Локальные промежуточные обработчики позволяют определить уникальное
поведение для определённых роутов. Например, аутентификацию запроса можно
реализовать с помощью локального промежуточного обработчика, один раз
определив функцию такого обработчика и добавляя её только в те роуты, где
пользователи должны быть аутентифицированны.
## Переменные в URL
Иногда вам может понадобиться иметь динамическую часть URL. Например, когда
вы реализуете сайт со статьями, где номер каждой статьи определён в URL, к
пример так: `/article/83774`. В таком URL динамической частью является
идентификатор статьи. Заранее, скорее всего, вам не будет известно сколько будет
статей и какие у них будут идентификаторы, и делать под каждую статью
обработчик будет довольно затратно, поэтому в express существует механизм URL
переменных. Давайте рассмотрим пример кода:
```javascript
const express =require('express');
const app =express();
app.get('/article/:id', (req, res) {
    res.send('<h1>Article № ${req.params.id}</h1>')
});
app.listen(3000);
```

Обратите внимание на первый аргумент. В него передаётся
строка `/article/:id`, где `:id` `express` расценивает, как динамическую часть URL. Динамическую часть URL вы можете именовать как угодно, например,
`/article/:articleID`. Таким образом в браузере можно сделать запрос на сервер с
таким URL `/article/748` и `express` запустит, этот обработчик.

Далее мы возвращаем клиенту заголовок, в который передаем номер статьи из URL. Данные, указанные в динамической части URL, хранятся в объекте `req` в свойстве `params`. Получить данные, которые были переданы из бразуера, можно по названию, который вы определили в URL – это `id`. 

Вы можете определить несколько переменных в URL. Предположим, что под
статьями можно оставлять комментарии и у каждого комментария свой
идентификатор. В таком случае, чтобы получить текст какого-то конкретного
комментария, необходимо определить следующий роут:
`/article/:articleID/comments/:commentID.`

Номер статьи можно получить в свойстве `req.params.articleID`, а номер комментария в свойстве `req.params.commentID`.

## Пропуск символов в URL
Ещё иногда вам может понадобиться сделать ваши URL более “дружелюбными” для
пользователей. Например, когда вы знаете, что пользователь может ошибиться в
URL, к примеру, в слове comment написать одну букву m. Для таких случаев `express` позволяет пропускать символы. Давайте посмотрим пример:
```javascript
const express =require('express');
const app =express();
app.get('/com?ment/', (req, res) {
    res.send('com?ment')
});
app.listen(3000);
```

в первом аргументе в слове comment указан специальный символ
`?`, который позволяет сделать запрос как на URL `/comment`, так и на `/coment`. Знак вопроса говорит `express` о том, что последующий за этим знаком символ может быть пропущен.

## Повторение символов в URL
Также можно указать, какие символы могут быть повторены несколько раз. Для
этого необходимо использовать знак `+`. Например:

```javascript
const express =require('express');
const app =express();
app.get('/add+ress', (req, res) {
    res.send('add+ress')
});
app.listen(3000);
```
В первом аргументе в слове `address` добавлен знак `+` после второй
буквы `d`, и это означает, что предыдущий символ в URL можно указывать сколько
угодно раз. Например, так `adddress` или так `adddddddress`.
## Любые символы в URL
Ещё есть возможность в URL, что могут быть повторены любые символы. Для этого
необходимо использовать знак `*`. Например
```javascript
const express =require('express');
const app =express();
app.get('/add*ress', (req, res) {
    res.send('add*ress')
});
app.listen(3000);
```
В этом примере в роуте, между буквой `d` и `r` можно указать любые символы в любом количестве.
## Возврат HTML файла
До сих пор во всех примерах вы могли наблюдать, что HTML конечному клиенту
передаётся в виде строки прямо в коде. Но HTML код может быть большим и
держать его в строке будет не очень удобно. В express существует для этого
возможность возврата файла в качестве ответа на запрос с помощью метода
`res.sendFile()`. Допустим, существует скрипт сервера и в этой же директории
находится файл `index.html`, который мы хотим использовать в качестве ответа.

```javascript
const express =require('express');
const app =express();
app.get('/', (req, res) {
    res.sendFile(path.join(__dirname, '/index.html')  )
});
app.l
```
Здесь происходит вызов метода `app.sendFile()` и в первый аргумент
этого метода передаётся строка с путём к HTML файлу. Путь к файлу должен быть
абсолютным, именно поэтому в примере используется модуль `path` и его метод
`path.join()`. Также используется глобальное свойство `__dirname`, которое хранит
информацию о том, в какой директории находится скрипт. Таким образом, передав
в `path.join()` две составляющие: `__dirname` и название файла, метод возвращает
полный путь к HTML файлу.
## Статичные файлы
Ещё express позволяет определить директорию, файлы которой будут доступны из
браузера. Такие файлы называются статичными. Для того чтобы определить такую
директорию, необходимо использовать промежуточный обработчик `express.static()`.
Давайте посмотрим на пример:

```javascript
const express =require('express');
const app =express();
app.use(express.static('static'));
app.get('/', (req, res) {
    res.sendFile(path.join('static/index.html')  )
});
app.listen(3000);
```
Здесь используется метод ``app.use()`` для регистрации глобального
промежуточного обработчика. В первый аргумент метода `app.use()` передаётся
результат выполнения функции `express.static(‘static’)` которая, в свою очередь,
принимает в первом аргументе путь к директории, где хранятся статичные файлы.
Обычно такую директорию называют static. Далее на восьмой строке в метод
`res.sendFile()` передаётся путь к HTML файлу, текст которого необходимо вернуть вкачестве ответа. При этом можно не указывать абсолютный путь к файлу,
достаточно указать путь от директории, в которой хранятся статические файлы.

Помимо всего прочего, статические файлы можно запросить прямо из браузера.
Допустим, в директории static хранится два файла: index.html и about.html. Для того чтобы получить их содержимое, можно не писать отдельный роут, а просто указать имя файла прямо в URL таким образом: `http://localhost:3000/index.html` или `http://localhost:3000/about.html`

## Использование статичных файлов
Чаще всего, HTML страницы реализуются в паре с таблицами стилей. Для того чтобы
в HTML использовать CSS файлы, можно воспользоваться механизмом раздачи
статичных файлов. Допустим, у вас есть такой HTML файл:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>my site</title>
</head>
<body>
        <h1>Main page</h1>
</body>
</html>
```
Чтобы подключить стили к этому файлу, необходимо в заголовок добавить тег
`<link/>`. В самом теге необходимо определить атрибут `href`, в котором нужно указать ссылку на CSS файл. Так как в директорию со статическими файлами можно
поместить любые файлы, это как раз позволяет создать файл `index.css` в этой
директории и ссылаться на него в HTML файле

Также можно посмотреть содержимое файла CSS в браузере. Достаточно напрямую
к нему обратиться `http://localhost:3000/index.css`.

Официальная документация [express](http://expressjs.com/ru)

# Урок 4. Написание API с применением подхода REST

* Шаблонизация
* Что такое API?
* Основные правила REST
* Работа с Postman
* Реализация методов POST, PUT, DELETE в
* express
* Реализация API для работы со статьями

Шаблонизатор - это инструмент, который позволяет создавать HTML код,
который генерируется в зависимости от входных данных.

## Как работают шаблонизаторы?
<image src="./images/10.jpg">
* На вход шаблонизатор принимает шаблон, который написан на специальном
языке разметки, в котором есть возможность указать места, куда необходимо вставить данные.
* Также шаблонизатору на вход необходимо подать данные, которые заменят в
шаблоне ранее определенные места для подстановки данных.
* На выходе шаблонизатор нам дает готовую HTML строку.

Существует большое количество шаблонизаторов для `JavaScript`, например: `EJS`,
`Mustache`, `Pug`, `Handlebars` и так далее. Все они работают по схожему принципу.

### Handlebars

Handlebars можно установить с помощью команды `npm install handlebars`.

Пример использования `Handlebars`.
```javascript
const handlebars =require('handlebars');
```
После того, как импортируется `Handlebars`, необходимо скомпилировать шаблон. 
```javascript
const template =handlebars.compile('<p> {{someVar}} </p>');
```
В метод `compile()` в первый аргумент необходимо передать текст шаблона. В нашем
случае он выглядит следующим образом `<p>{{someVar}}</p>`.

`{{someVar}}` в строке шаблона - это место, куда подставится значение переменной с именем `someVar`. То есть если передать шаблонизатору такую переменную со
строковым значением `“Hello”`, то вместо `<p>{{someVar}}</p>` на выходе мы
получим `<p>Hello!</p>`

Таким образом получается, что любую переменную, значение которой мы хотим вставить в наш HTML, необходимо обернуть в двойные фигурные скобки `{{}}`.


Метод `.compile()` возвращает функцию, которую можно вызвать для получения `HTML`
кода. При вызове этой функции, необходимо передать в первый аргумент объект,
свойства которого будут переданы в шаблон.

```javascript
const handlebars =require('handlebars');
const template =handlebars.compile('<p> {{someVar}} </p>');
const result= template( {someVar: "Hello!" } );
console.log(result);
```

**! Имя свойства должно совпадать с именем переменной, которая ожидается в шаблоне**

В шаблоне можно передавать и использовать сколько угодно свойств.

## Условный оператор

Еще вы можете использовать условные конструкции в шаблоне. Для этого
необходимо использовать следующий синтаксис:
```javascript
{{#if переменная }} <p></p> {{else}} <b></b> {{/if}}
```
Начинается условие с двойных фигурных скобок и оператора `#if` Условие должно закрываться с помощью оператора `{{/if}}`.

Пример
```javascript
const handlebars =require('handlebars');
const template = handlebars.compile(
    '{{ #if bold }} <b>Hello!</b> {{ else }} <p>Hello!</p> {{/if}}'

);
console.log(template({bold: true}));
console.log(template({bold: falce}));
```
Здесь в шаблоне ожидается, что если переменная `bold` будет иметь значение `true`,то в итоговом `HTML` вернется `<b>Hello!</b>`. В ином случае, если `bold` равен `false`, то в итоговом результате возвращается `<p>Hello!</p>`.

## Перебор массива в цикле
`Handlebars` не ограничивается условными конструкциями. Также можно перебирать
элементы массива в цикле. Это может быть очень удобно для тех случаев, когда вам
нужно вывести какие-нибудь списки в `HTML`.

Синтаксис довольно простой:
```javascript
{{ #each массив}} <p>{{this}}</p> {{ /each }}>
```
Перебор начинается с оператора `#each` и через пробел указывается массив,
который необходимо перебрать. Далее в теле цикла можно указать `HTML` код,
который нужно вывести. Внутри тела можно использовать оператор `{{this}}`. Этот
оператор позволяет вставить значение элемента массива в финальный `HTML`.

Пример
```javascript
const handlebars =require('handlebars');
const items = [
    {name:'first item'},
    {name:'second item'},
];
const template = handlebars.compile(
    '{{#each items}}' <p> {{this.name}} </p> {{/each}}
);
console.log(template({items}));
```

## Handlebars в express

Файловая структура примера будет выглядеть следующим образом.
<image src="./images/11.jpg">

Здесь вы можете увидеть, что имеется директория `templates` с файлом
`home.handlebars`. В рамках этого примера текст шаблона вынесен в отдельный
файл, который как раз будет храниться в `templates/home.handlebars`. Это нужно для удобства редактирования кода шаблона и для чистоты кода сервера.

Теперь рассмотрим файл сервера `index.js`.

```javascript
const fs = require('fs');
const path = require('path');

const express = require('express');
const handlebars = require('handlebars');
const app = express();

const articles = [
    {title: 'Article_1', description: 'First awesome article'},
    {title: 'Article_2', description: 'Second awesome article'},
    {title: 'Article_3', description: 'Third awesome article'},
];

app.get('/',(req, res)=>{
    const pathToTemplate = path.join(__dirname, '/templates/handlebars');
    fs.readFile(pathToTemplate, 'utf-8',(err, data)=>{
        if(err){
            res.status(500);
            res.send(err.message);
        } else{
            const template = handlebars.compile(data);
            res.send(template( {articles} ))
        };
    });
});

```
Этот код позволяет вывести список статей, информация о которых хранится в
массиве. В первую очередь импортируются четыре модуля: `fs`, `path`, `express` и `handlebars`.

Далее определен массив `articles`, данные которого будут использоваться в генерации списка статей.

```javascript
const articles = [
    {title: 'Article_1', description: 'First awesome article'},
    {title: 'Article_2', description: 'Second awesome article'},
    {title: 'Article_3', description: 'Third awesome article'},
];
```

Далее определен обработчик запросов. В теле обработчика с помощью метода `.join` модуля `path` объединяется путь к директории скрипта(`__dirname`) и путь к файлу, в котором хранится шаблон `Handlebars`. Это позволяет получить полный путь к файлу шаблона.

```javascript
app.get('/',(req, res)=>{
    const pathToTemplate = path.join(__dirname, '/templates/handlebars');
```

Далее загружается файл шаблона с помощью метода `.readFile()` модуля `fs`.

Если вдруг не получилось загрузить файл шаблона, то необходимо пользователям
сервера дать понять, что что-то пошло не так. По этому определяем статус ответа
`500`(ошибка на стороне сервера) и отправляем текст ошибки.

```javascript
app.get('/',(req, res)=>{
    fs.readFile(pathToTemplate, 'utf-8',(err, data)=>{
        if(err){
            res.status(500);
            res.send(err.message);
```

Если же текст шаблона успешно загружен, то компилируем его с помощью метода
`handlebars.compile()` и передаем в первый аргумент `data` - это текст из файла,
который был только что загружен.

Когда шаблон скомпилирован, вызываем `res.send()` и передаем в первый аргумент
результат запуска функции `template`, а также передаем в функцию `template()` в
объекте массив

```javascript
app.get('/',(req, res)=>{
    const pathToTemplate = path.join(__dirname, '/templates/handlebars');
    fs.readFile(pathToTemplate, 'utf-8',(err, data)=>{
        if(err){
            res.status(500);
            res.send(err.message);
        } else{
            const template = handlebars.compile(data);
            res.send(template( {articles} ))
        };
    });
});
```

Cам файл шаблона
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Handlebars example</title>
</head>
<body>
    <h1>Articles list</h1>
    {{#each articles}}
    <h2>{{this.title}}</h2>
    <p>{{this.description}}</p>
    {{/each}}
</body>
</html>
```

В действительности, такая реализация не сильно проще, чем конкатенация строки, но на самом деле есть возможность упростить работу с `Handlebars` с помощью библиотеки `express-handlebars`!
## Библиотека express-handlebars
Библиотеку `express-handlebars` можно установить с помощью команды `npm install express-handlebars`.
После установки библиотеки, вы можете импортировать её в коде сервера и начать использовать. Давайте взглянем на пример генерации точно такой же страницы, как в прошлом примере:

<image src="./images/12.jpg">

Начнем с файловой структуры примера. Здесь есть некоторые отличия
относительно прошлого примера. Теперь вместо `templates`, для хранения шаблонов `Handlebars` определена директория `views`. Внутри этой директории хранится файл нашего шаблона `home.handlebars`, а также другая директория `layouts` в которой имеется файл `main.handlebars`/ С назначением директории layouts мы разберемся чуть позже, а пока давайте рассмотрим код сервера:

```javascript
const express = require('express');
const { engine } = require('express-handlebars');
const app = express();

app.engine('handlebars', engine());
app.set('view engine', 'handlebars');
app.set('views', './views');

const articles = [
    {title: 'Article_1', description: 'First awesome article'},
    {title: 'Article_2', description: 'Second awesome article'},
    {title: 'Article_3', description: 'Third awesome article'},
];

app.get('/', (req, res)=>{
    res.render('home',{ title:'home', articles});

});
app.listen(3000);
```
 Давайте разберем код построчно.

В первую очередь необходимо импортировать модули express и `express-handlebars`. Причем от `express-handlebars` нам нужен только метод engine, который извлекается при помощи деструктуризации объекта JavaScript.

```javascript
const express = require('express');
const { engine } = require('express-handlebars');
```
Далее идет ряд важных инициализаций. В первую очередь создаем приложение
`express`
```javascript
const app = express();
```

Далее используется метод приложения `express` `.engine()`. Этот
метод необходим для того, чтобы зарегистрировать шаблонизатор. `Express` умеет работать со многими шаблонизаторами, об этом можно почитать в этой
[документации](https://expressjs.com/ru/guide/using-template-engines.html).

```javascript
const express = require('express');
const { engine } = require('express-handlebars');
const app = express();

app.engine('handlebars', engine());
```
Далее определяется шаблонизатор по-умолчанию с помощью метода `app.set()`

`app.set()` - это метод, который позволяет сохранить любое свойство в
приложении `express`, которое вы захотите и получить его с помощью метод
`app.get()`, но есть ряд зарезервированных свойств, которые нужно
использовать для конфигурации приложения. В первый аргумент метода
передается имя свойства, а во второй значение свойства. Более подробно
об этом методе можно почитать в [документации](https://expressjs.com/ru/api.html#app.set) `express`


Свойство `view engine` позволяет `express` понять, какой шаблонизатор нужно
использовать по-умолчанию. Значением этого свойства необходимо указать
`handlebars`

```javascript
app.set('view engine', 'handlebars');
```
Свойство `views` – это путь к директории, в которой будут храниться шаблоны. Значением необходимо указать `./views`
```javascript
app.set('views', './views');
```

Теперь давайте посмотрим на обработчик запросов:
```javascript
app.get('/', (req, res)=>{
    res.render('home',{ title:'home', articles});
});
```
Тут уже не используется метод `res.send()`, а используется метод `.render`. Этот метод позволяет определить в первом аргументе, какой шаблон нужно использовать, а во втором аргументе, какие данные будут переданы в шаблон. В нашем случае названием шаблона является home, так как в директории views хранится шаблон `home.handlebars`. Расширение файла можно не указывать. Во второй аргумент передано свойство `title`. Значение этого свойства будет использоваться в качестве заголовка страницы. Также передан массив статей `articles`, который будет использован в шаблоне, для генерации списка.

Посмотрим на шаблон `./views/home.handlebars`
```handlebars
<h1>Articles list</h1>
{{#each articles}}
<h2>{{ this.title }}</h2>
<p>{{ this.description }}</p>
{{/each}}
```

Здесь вы можете увидеть уже знакомый вам код генерации списка статей. Но здесь нет основы `html` страницы: тега `<head/> и <body/>`. Это не спроста, так как весь этот код “прячется” в файле `./views/layouts/main.handlebars`.
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{title}}</title>
</head>
<body>
    {{{body}}}
</body>
</html>
```

Файл `./views/layouts/main.handlebars` является основой для всех шаблонов.
Код любого шаблона будет вставлен в место, где определен специальный оператор `{{{body}}}`. Такой подход позволяет не писать один и тот же код несколько раз, а сконцентрироваться на написании изменяемой части страницы.

`Handlebars` по-умолчанию ищет в директории `./views/layouts` файл `main.handlebars`, но вы можете переопределить слой шаблона во время вызова функции `res.render()`, передав во втором аргументе в объекте свойство `layout` с названием шаблона. Например, если создать файл `./views/layouts/index.handlebars`, то для его использования при вызове функции необходимо передать информацию таким образом:

```javascript
app.get('/', (req, res)=>{
    res.render('home',{ 
        layout: 'index',
        title:'home', 
        articles});
});
```
То есть рядом с информацией, которая нужна шаблону для формирования списка
статей, также передается `layout: 'index'`.

## Промежуточные итоги
Кроме в `#if` и `#each`  у `Handlebars` довольно много различных операторов.
 Почитать о них вы можете в официальной [документации](https://handlebarsjs.com/guide/expressions.html#basic-usage)

Вы можете использовать шаблонизаторы, для того, чтобы генерировать на бекенде HTML страницы - фактически делать фронтенд на бекенде. Но шаблонизаторы
также можно использовать только на фронтенде, для динамической генерации
различных элементов интерфейса. На данный момент шаблонизаторы на
фронтенде используют редко, так как популярные фреймворки имеют свои
собственные шаблонизаторы.

## API

Аббревиатуры `API` - Application Programming Interface.

`API` - это механизм, который позволяет двум программным компонентам
взаимодействовать друг с другом, используя определенный набор правил.
В контексте веб-серверов существуют несколько подходов, но мы рассмотрим самый популярный и в то же время простой доход - это `REST`.

## REST

`REST` - это набор правил межсервисного общения в вебе. Давайте посмотрим на два самых важных правила в этом подходе:
* `URL` должен в себе нести информацию об объекте, с которым мы работаем
* Роуты, которые вы реализуете, должны использовать методы `GET`, `POST`, `PUT`, `DELETE` - это действия над объектами, которые мы хотим с ними совершить.

`URL` должен в себе нести информацию об объекте. Это означает, что в `URL` мы должны использовать только существительные и избегать использования глаголов и прилагательных. Также помимо существительных в `URL` необходимо использовать идентификаторы объектов для работы с конкретными объектами. 

`URL` должен состоять из сегментов, где каждый отдельный элемент - это либо объект, либо идентификатор, например: `/объект_1/идентифкатор/объект_2/идентификатор`.

Методы `GET`, `POST`, `PUT`, `DELETE` - это действия над объектами. Так как в `URL`
хранится информация об объекте, с которым мы работаем, то метод запроса
является действием над этим объектом. 
* GET - это получение информации об объекте
* POST - это создание нового объекта
* PUT - это обновление существующего объекта
* DELETE - это удаление объекта.


Давайте рассмотрим пример, в котором мы работаем с объектами статей:

* `GET /articles/3` - получить статью с идентификатором три. Здесь первым
сегментом `URL` является объект статьей, а вторым сегментом - идентификатор конкретной статьи
* `GET /articles` - получить объекты всех статей. Так как здесь нет
идентификатора - это расценивается, как получение всех указанных
объектов. Обратите внимание, что объект статьи определен во множественном числе именно потому, что иногда нам необходимо получать
сразу несколько объектов.
* `POST /articles` - создать статью. Тут мы указываем в `URL` объект, который
хотим создать без указания идентификатора, так как перед созданием мы
еще не знаем, какой идентификатор будет у статьи. Обычно идентификаторы
уникальны и создаются сервером во время создания и нам нет необходимости его указывать вручную.
* `PUT /articles/3` - обновить третью статью. Здесь мы намеренно указываем
идентификатор конкретной статьи, так как без него непонятно, какую конкретно статью мы хотим обновить.
* `DELETE /articles/3` - удалить третью статью. Ровно также, как и с
обновлением, необходимо указать с помощью идентификатора, какую статью
нужно удалить.

Часто бывает так, что объекты зависят друг от друга. В таком случае в `URL`
необходимо соблюдать эту зависимость. Например, у каждой статьи есть
комментарии, которые привязаны к конкретной статье. Нельзя создать
комментарий к одной статье и посмотреть в другой. Чтобы реализовать такую
зависимость в REST, необходимо поступать следующим образом:
* `GET /articles/3/comments` - получить список комментариев третьей статьи.
* `GET /articles/3/comments/1` - получить первый комментарий третьей статьи.
* `POST /articles/3/comments` - создать комментарий к третьей статье.
* `PUT /articles/3/comments/1` - обновить первый комментарий третьей статьи.
* `DELETE /articles/3/comments/1` - удалить первый комментарий третьей
статьи

Такой подход к организации зависимых объектов позволяет не ошибиться и указать
объект именно в той последовательности, в которой объекты зависят друг от друга, при получении комментария обязательно придется указывать конкретную статью.
Если `URL` будет реализован таким образом` GET comments/1/articles/3`,
пользователь вашего `API` может не указать объект статьи и попробовать получить
только комментарий `GET comments/1`, что не получится обработать сервером, так
как комментариев с идентификатором `1` может быть несколько у разных статей.

## Тестирование работы сервера

**Postman** - это платформа для работы с API, которая позволяет
разработчикам проектировать, создавать, тестировать и документировать
свои API

## Установка Postman
Для того, чтобы установить Postman, необходимо зайти на сайт [postman](https://postman.com/) и нажать на кнопку загрузки.

Все запросы можно сохранять и возвращаться к ним по необходимости. Местом
хранения запросов в Postman являются коллекции.

Коллекция - это способ хранения и группировки запросов. Коллекций может быть
несколько. Обычно для одного сервера создается отдельная коллекция.

В каждой коллекции можно создавать директории, по аналогии с файловой
системой. Это необходимо для того, чтобы разделять в коллекции запросы по
сущностям. Например, одна директория для запросов связанных со статьями,
другая директория для запросов связанных с комментариями. Директории можно
создавать в других директориях.

Запросы - это такие сущности, которые хранят в себе информацию о методе запроса, `URL` передаваемых данных и т.д.

## Реализация API в Express

### Роут получения всех статей
В `REST` в `URL` необходимо указывать объект, с которым мы работаем, а `HTTP` метод - это действие над объектом.

Поэтому нам необходимо реализовать такой роут: `GET /articles`.
Обработчик этого роута будет возвращать массив статей. В коде это будет
выглядеть следующим образом:



```javascript
const express = require('express');
const app = express();
app.get('/articles', (req, res)=>{
    res.send({articles});
});
app.listen(3000);
```

### Роут создания статьи

Необходимо реализовать роут, который получит в теле запроса `JSON` объект с информацией о статье и в обработчике необходимо добавить в массив `articles` этот объект. Также есть важный нюанс - это идентификатор статьи. Каждая статья должна иметь уникальный идентификатор, для того, чтобы можно было по этому идентификатору получать, обновлять и удалять статью. Также важно понимать, что идентификатор должен генерировать и обеспечивать его уникальность сам сервер. Если мы переложим эту ответственность на пользователя нашего сервера, то велика вероятность, что пользователь ошибется в генерации идентификаторов и могут возникнуть коллизии.

Прежде, чем начать писать код, необходимо определиться, какие данные будут
храниться в объекте статьи. Для простоты будем считать, что объект статьи будет состоять из двух текстовых полей: `title` и `content`, а также поля `id` с идентификатором.

```javascript
{ 
    "id": 2,
    "title": "Some article title",
    "content":"Some article content"
}
```
Давайте посмотрим на часть кода нашего сервера с реализацией обработчика для
создания статей:
```javascript
let uniqueID = 0;
const articles = [];
app.post ('/articles',(req, res)=>{
    uniqueID += 1;
    articles.push({
        id: uniqueID,
        ... req.body
    });
 res.send({
    id: uniqueID,
    });   
});
```
Далее  в массив статей добавляется тело запроса, в котором хранится информация о статье. Так как статья должны быть уникальна, то мы
добавляем в объект статьи поле `id` с текущим значением идентификатора

```javascript
    articles.push({
        id: uniqueID,
        ... req.body
    });
```

Далее возвращается идентификатор статьи, которая была только что создана. Это необходимо для того, чтобы пользователь сервера мог дальше работать со статьей и знал, по какому идентификатору можно к ней обратиться.

```javascript
 res.send({
    id: uniqueID,
    }); 
```
В Postman запрос на создание статьи должен выглядеть примерно так:
<image src="./images/13.jpg">

### Роут получения статьи
Теперь давайте попробуем реализовать роут, который вернет информацию по
конкретной статье. Для этого необходимо реализовать роут, который будет
принимать идентификатор статьи в `URL`, далее искать необходимую статью в
массиве статей и возвращать найденный объект. В случае, если по переданному
идентификатору ничего не было найдено, необходимо завершить запрос с кодом
ответа `404`. Давайте посмотрим на код:

```javascript
const articles = [];
app.get('/articles/:id', (req, res)=>{
    const article = articles
    .find( (article) => article.id === Number(req.params.id));
    if(article){
        res.send({article})
    }else {
        res.status(400);
        res.send({ article: null});
    }
});
```
В первом аргументе метода `app.get()` в `URL` мы определяем переменную `:id`

Далее производится поиск статьи в массиве статей `articles` по идентификатору. Чтобы получить идентификатор, необходимо обратиться к объекту параметров `URL` `req.params.id`. Обратите внимание, что `req.params.id` “обернут” в `Number()` для приведения строки в число, так как значения параметров `URL` - это всегда строка.

```javascript
const articles = [];
app.get('/articles/:id', (req, res)=>{
    const article = articles
    .find( (article) => article.id === Number(req.params.id));
```
Далее, проверяем наличие статьи, и если искомая статья существует, то на восьмой строке возвращаем эту статью.

Если же искомой статьи нет в массиве, необходимо пользователю сервера указать на это. Необходимо указать код ответа `404` и в качестве ответа передать объект, в котором `article` будет `null`

### Роут обновления статьи

Для обновления статьи нам необходимо принять в `URL` запроса идентификатор статьи для обновления и далее по этому идентификатору найти в массиве нужную статью. Далее необходимо обновить объект статьи в массиве исходя из переданной информации в теле запроса. Давайте взглянем на код:
```javascript
const articles = [];
app.put('/articles/:id', (req, res)=>{
    const article = articles
    .find((article)=> article.id === Number(req.params.id));
    if(article){
        article.title = req.body.title;
        article.content = req.body.content;
        res.send({article});
    }esle{
        res.status(404);
        res.send({article: null});
    }
});
```

### Роут удаления статьи
Для удаления статьи необходимо принять в `URL` запроса идентификатор статьи,
найти искомую статью в массиве и удалить её объект из массива. Давайте
посмотрим на код:

```javascript
const articles = [];
app.delete('/articles/:id', (req, res)=>{
    const article = articles
    .find((article)=> article.id === Number(req.params.id));
    if(article){
        const articleIndex = articles.indexOf(article);
        articles.splice(articleIndex ,1);
        res.send({article})
    }esle{
        res.status(404);
        res.send({article: null});
    }
});
```
Обратите внимание, что в этом обработчике мы не используем тело запроса,
так как вся необходимая информация об удаляемой статье хранится в `URL`
запроса, а именно идентификатор статьи.

## Валидация данных

Что будет, если пользователь при создании статьи не передаст `title` или `content`? Так как во время создания статьи мы никак не проверяем передаваемые данные, передаваемый объект сохранится в массив и далее работа нашего сервера будет непредсказуемой, так как в обработчиках мы ожидаем наличие полей `title` и `content`.

Задачу валидации можно решать с помощью специальных библиотек валидации, которые позволяют сократить количество кода, а также помогают валидировать различные специализированные данные, такие как номер телефона, географический адрес, адрес электронной почты и так далее.
## Валидатор Joi

Чтобы установить библиотеку, достаточно в консоли набрать команду `npm install joi`. После установки можно импортировать эту библиотеку и начать ей пользоваться.

Давайте посмотрим на работу `Joi` пока что в отрыве от HTTP сервера:


```javascript
const Joi = require('joi');
const schema = Joi.string();
const result = schema.validate('Some string');
console.log(result)
```
Для того, чтобы разобраться, как работает этот код, необходимо усвоить важную
концепцию валидатора `Joi`: прежде, чем валидировать данные, необходимо создать
схему валидации, которая описывает, какие данные в каком формате мы хотим
валидировать. Затем, используя созданную схему можно валидировать любые
данные сколько угодно раз.

В строке
```javascript
const schema = Joi.string();
```
определяется схема валидации. Для этого необходимо обратиться к модулю `Joi` и вызвать необходимые методы. В нашем примере вызывается метод `Joi.string()`, что означает, что данные, которые мы будем валидировать должны быть строкой. Схему необходимо записать в
переменную, так как далее мы будем использовать эту схему для валидации
данных.

В строке 
```javascript
const result = schema.validate('Some string');
```
на ранее определенной схеме вызывается метод `.validate()` и
в первый аргумент передаются данные, которые мы хотим провалидировать.
В нашем случае - это строке `“Some string”`. Функция `.validate()` возвращает
результат валидации.

Вот что будет в консоли, если запустить этот код:

<image src="./images/14.jpg">

Если валидация прошла успешно, то метод `.validate()` возвращает объект, в котором
в поле value хранится исходное значение, которое валидировалось. Но что, если
данные не пройдут валидацию? Давайте в исходном коде в метод `.validate()`
передадим не строку, а например число.
```javascript
const Joi = require('joi');
const schema = Joi.string();
const result = schema.validate(123);
console.log(result)
```
Запустив такой код, в консоли вы увидите следующий вывод:

<image src="./images/15.jpg">

Как видите, `Joi` в объект, помимо value, добавил поле error, в котором хранится
информация об ошибке. Чтобы получить конкретное сообщение об ошибке, можно
обратиться к полю `result.error.details`. В этом поле хранится массив всех ошибок:

```javascript
console.log(result.error?.details)
```
Теперь сообщение в консоли будет выглядеть так
<image src="./images/16.jpg">

Как валидировать другие типы данных? Давайте посмотрим на пример валидации
объекта статьи:

```javascript
const Joi = require('joi');
const schema = Joi.object({
    id: Joi.number().required(),
    title: Joi.string().min(1).required(),
    content: Joi.string().min(10).required(),
});
const result = schema.validate({
    id:1,
    title: '1',
    content: '12345687687'
});
console.log(result.error?.details)
```

Определена схема валидации объекта. Для валидации
объекта в `Joi` существует метод `Joi.object()`, который в первый аргумент
принимает JavaScript объект. Чтобы провалидировать конкретные поля в
объекте, необходимо определить эти поля и в качестве значения определить
схемы.

```javascript
const Joi = require('joi');
const schema = Joi.object({
    id: Joi.number().required(),
    title: Joi.string().min(1).required(),
    content: Joi.string().min(10).required(),
});
```

В строке
```javascript
    id: Joi.number().required(),
```
 определено поле `id`, а значением этого поля является
цепочка методов валидации `Joi`. Давайте разберем схему валидации поля `id`.
`Joi.number()` говорит о том, что в поле должно быть число. Далее по цепочке
вызывается метод `.min()`, который определяет минимальное число, которое
может быть передано в качестве идентификатора - это число 1, оно
передается в первый аргумент метода `.min()`. После этого в цепочке вызовов
вызывается метод `.required()`, который говорит о том, что поле `id` обязательно
и без него валидация не пройдет. Таким образом эту схему можно читать
следующим образом: идентификатор - это обязательное поле, с типом
number и минимальным значением 1.

Если вы запустите такой код, то в консоли вы увидите `undefined`, так как валидация
прошла успешно, переданный объект соответствует всем требованиям.

Давайте теперь передадим в метод `.validate()` объект, который не соответствует
схеме валидации, например будет отсутствовать поле `title`.

```javascript
const result = schema.validate({
    id:1,
    content: '12345687687'
});
```
Запустив код с таким объектом, в консоли вы увидите следующее:
<image src="./images/17.jpg">

## Применение Joi в Express

Теперь давайте попробуем использовать `Joi` в нашем коде сервера, в частности в
обработчике создания статьи:

```javascript
const articleScheme = Joi.object({
    title: Joi.string().min(5).required(),
    content: Joi.string().min(10).required(),   
});

app.post('/articles', (req, res)=>{
    const articleValidationResult = articleScheme
    .validate(req.body);

    if (articleValidationResult.error){
        return res
        .status(404);
        .send(articleValidationResult.error.details);
    }

    uniqueID += 1;
    articles.push({
        id: uniqueID,
        ...req.body
    });

    res.send({
        id: uniqueID,
    });
})
```
На первой строке определена схема валидации объекта статьи. В обработчике запроса `app.post()` вызывается метод валидации на схеме валидации и передается тело запроса.

Далее проверяется наличие ошибок, и если ошибки имеются, клиенту возвращается ответ с кодом 400 и сообщением с объектом ошибки из результата валидации.

Давайте еще посмотрим на пример валидации роута обновления статьи:
```javascript
const articleScheme = Joi.object({
    title: Joi.string().min(5).required(),
    content: Joi.string().min(10).required(),   
});
const idScheme = Joi.object({
    id: Joi.number().required(),
})

app.put('/articles/:id', (req, res)=>{
    const idValidationResult = idScheme
        .validate(req.params);

    if (idValidationResult.error){
        return res
        .status(404);
        .send(idValidationResult.error.details);
    }

    const articleValidationResult = articleScheme
        .validate(req.body);

    if (articleValidationResult.error){
        return res
        .status(404);
        .send(articleValidationResult.error.details);
    }

    const article = articles
        .find((article)=> article.id === Number(req.params.id));

    if( article){
        article.title = req.body.title;
        article.content = req.body.content;

        res.send({article})
    }else {
        res.status(404);
        res.send({article: null})

    }
})
```

Здесь, помимо схемы валидации тела запроса, в  строке 
```javascript
const idScheme = Joi.object({
    id: Joi.number().required(),
})
```
определена схема валидации параметров `URL`.  Так как `req.params` - это объект, то и схема
валидации описывает объект с полем `id`. Поле `id` в нашем случае число и это обязательный параметр.

Такой способ валидации с `Joi` также, как и вариант валидации с помощью
условных конструкций довольно трудоемкий, нужно писать много кода в каждом
обработчике. Эту проблему довольно легко решить с помощью промежуточных
обработчиков `Express`!
## Валидация в промежуточных обработчиках
Для того, чтобы код был более читабельным, необходимо его разбить на несколько
файлов. Ниже представлена файловая структура, в которой схемы валидации и
промежуточные обработчики вынесены в отдельные файлы.
<image src="./images/18.jpg">

Директория `validation` хранит в себе два файла: `scheme.js` и `validator.js`. Давайте
разберемся с первым файлом - `scheme.js`.

```javascript
//`scheme.js`
const Joi = require('joi');
const articleScheme = Joi.object({
    title: Joi.string().min(5).required(),
    content: Joi.string().min(10).required(),
});

const idScheme =Joi.object({
    id:Joi.number().requied(),
})
module.exports ={ articleScheme, idScheme }
```

Тут уже знакомые вам схемы валидации объекта статьи и идентификатора. Далее  эти схемы. экспортируются. В дальнейшем в файле сервера `index.js` будет достаточно импортировать этот модуль и использовать нужную схему.

Теперь разберемся с файлом `validator.js`

```javascript
//`validator.js`
function checkParams(schema){
    return (req, res , next)=>{
        const validationResult = schema.validate(req.params);
        if(validationResult.error){
            return res.status(400).send(validationResult.error.details);
        }
        next();
    }
}

function checkBody (req, res, next){
    return (req, res) => {
        const validationResult =  schema.validate(req.body);
        if(validationResult.error){
            return sen.status(400).send(validationResult.error.details);
        }
        next();
    }
}
module.exports = {checkParams, checkBody};
```

Здесь определены две функции: `checkParams` и `checkBody`. Эти функции являются
промежуточными обработчиками `Express`.

Каждая функция принимает в качестве аргумента схему валидации `Joi`. То есть при вызове функции необходимо передать ту схему, по которой необходимо провалидировать данные.

Также функции возвращают другую функцию, которая по набору аргументов покажется вам знакомой. В первом аргументе возвращаемой функции передается объект запроса Express, во втором аргументе объект ответа, а в третьем специальная функция `next()`, которая вызывает следующий
обработчик в цепочке.
```javascript
return (req, res) => {
```
Внутри возвращаемой функции на схеме `scheme` вызывается функция validate и в первый аргумент передается либо `req.body`, либо `req.params`. Функция возвращает результат валидации
```javascript
const validationResult = schema.validate(req.params);
const validationResult =  schema.validate(req.body);
```
Далее проверяется результат валидации, и если есть ошибки, то сразу же возвращается ответ пользователю с `HTTP` кодом `400(Bad Request)`. Если же все хорошо и валидация данных не дала ошибок, вызывается функция `next()`, которая запускает следующий обработчик по цепочке.

```javascript
if(validationResult.error){
    return res.status(404).send(validationResult.error.details);
}
next();
```
Теперь давайте взглянем на то, как использовать модули `scheme.js` и `validator.js` в
коде сервера.


Первое, что необходимо сделать, это импортировать эти модули 
```javascript
const {checkBody, checkParams} = require('/validation/validator');
const {idScheme, articleScheme} = require('./validation/scheme');
```
и деструктурировать их экспорт, для дальнейшего использования схем и промежуточных обработчиков. Далее возьмем в качестве примера обработчик обновления статей.

```javascript
app.put('/articles/:id', checkParams(idScheme), checkBody(articleScheme), (req, res)=>{
    const article = articles.find((article)=>article.id ===Number(req.params.id));
    if(article){
        article.title = req.body.title;
        article.content =  req.body.content;

        res.send({article})
    }else{
        res.status(404);
        res.send({article: null});
    }
});
```
Здесь на первой строке происходит вся магия промежуточных обработчиков.
```javascript
app.put('/articles/:id', checkParams(idScheme), checkBody(articleScheme), (req, res)=>{
```
В методе `app.put()` первым аргументом указывается `URL` с параметром `:id`

Далее во втором аргументе передается результат выполнения функции `checkParams()`, в которую в свою очередь передана схема валидации. Если вернуться к реализации функции `checkParams()`, то сразу становится понятно, что эта функция вернет. Вернет она функцию обработчик `Express`, которая запустится, когда поступит запрос на определенный ранее роут.


Третьим аргументом в метод `app.put()` передается результат выполнения функции `checkBody()`, которая также вернет функцию обработчик `Express`. Ну а в четвертом аргументе определен основной обработчик Чтобы лучше понять работу промежуточных обработчиков валидации, взгляните на схему ниже:

<image src="./images/19.jpg">

Когда клиент делает запрос на роут `PUT /articles/1`, `Express` запускает обработчики в
том порядке, в котором они были переданы в аргументах. Сначала вызывается
функция, которая была возвращена из функции `checkParams`. Если валидатор дал
ошибку, то обработка запроса прервется и пользователю вернется ответ с кодом
`400`. Если же валидация прошла успешно, вызывается следующий обработчик по
порядку с помощью функции `next()`. Следующий обработчик по порядку - это
валидатор тела запроса. Он работает ровно также, как и предыдущий обработчик.
Если валидация пройдена, вызовется функция `next()` и запуститься основной
обработчик. Теперь промежуточные обработчики можно использовать в любом запросе,
например мы можем переиспользовать `checkBody()` в обработчике создания статьи.

Выглядеть это будет следующим образом:

```javascript
app.post('/articles/:id', checkBody(articleScheme), (req, res)=>{
    uniqueID += 1;
    articles.push({
        id: uniqueID,
        ...req.body
    });
    res.send({
        id:uniqueID,
    });
});
```
Здесь перед основным обработчиком добавлен промежуточный обработчик `checkBody()` и этого достаточно для того, чтобы проверить тело запроса на валидность.

в таком варианте организации кода будет не сложно изменить схему валидации, например если при создании и обновлении статьи необходимо передавать дополнительное поле, для этого достаточно в схему `articleScheme` добавить поле и описать его схему.

Наш сервер почти готов! Осталось добавить глобальный промежуточный обработчик
несуществующих роутов. 

```javascript
app.use((req, res)=>{
    res.status(404).send({
        message: 'URL not found'
    })
  
})
```

**Важно** помнить, что этот обработчик должен быть определен после всех обработчиков роутов.

Теперь давайте взглянем на основной код сервера:

```javascript
const express = require('express');
const {checkBody, checkParams} = require('/validation/validator');
const {idScheme, articleScheme} = require('/validation/shema');
const app = express();

let uniqueID = 0;
const articles = [];
app.use(express.json());

//Получить все статьи 
app.get('/articles', (req, res)=>{
    res.send({articles});
});

// Получить конкретную статью
app.get('/articles/:id', checkParams(idScheme),(req, res)=>{
    const article = articles.find((article)=>article.id === Number(req.params.id));
    if (article){
        res.send({article});
    }else{
        res.status(404).send({article:null});
    }
});

//Создание статьи 
app.post('/articles/', checkBody(articleScheme), (req, res)=>{
    uniqueID+= 1;
    articles.push({
        id:uniqueID,
        ...req.body
    });
    res.send({
        id:uniqueID,
    });
});

// Обновление статьи
app.put('/articles/:id', checkParams(idScheme), checkBody(articleScheme), (req, res)=>{
    const article = articles.find((article)=>article.id === Number(req.params.id));
    if(article){
        article.title = req.body.title;
        article.content = req.body.content;

        res.send({article})
    }else{
        res.status(404).send({article:null});
    }
});

//  Удаление статьи
app.delete('/articles/:id', checkParams(idScheme), (req, res)=> {
    const article = articles.find((article)=> article.id ===Number(req.params.id));
    if(article){
        const articleIndex = articles.indexOf(article);
        articles.splice(articleIndex, 1);

        res.send({article});
    }else{
        res.status(404).send({article:null});
    }
});

// Обработка несуществующих роутов
app.use((req, res)=>{
    res.status(404).send({
        message: 'URL not found',
    });
});

app.listen(3000);
```

## Дополнительные материалы

* Хорошая [статья](https://habr.com/ru/articles/273581/) по работе с шаблонизатором `Handlebars`
* [Статья](https://aws.amazon.com/ru/what-is/api) про API и различные их виды 
* Мы довольно верхнеуровнево затронули REST. Для получения больших деталей можно почитать эту [статью](https://tproger.ru/articles/osnovy-rest-teorija-i-praktika)


## Словарь терминов
**Шаблонизатор** - это инструмент, который позволяет создавать HTML код, который
генерируется в зависимости от входных данных.

**API** (Application Programming Interface) - это механизм, который позволяет двум программным компонентам взаимодействовать друг с другом, используя
определенный набор правил.

**REST** - это набор правил межсервисного общения в вебе. Основными правилами
этого подхода - это то, что URL хранит в себе информацию об объекта, с которыми
мы работаем, а HTTP метод хранит информацию о действии над объектами.

**Postman** - это платформа для работы с API, которая позволяет разработчикам
проектировать, создавать, тестировать и документировать свои API.
