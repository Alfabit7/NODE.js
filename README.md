# Лекция 1
Предпосылки к созданию Node.js

## Что такое Node.js?
Раян Даль - Американский инженер-программист cоздатель Node.js
`Node.js` — это платформа, которая позволяет разработчикам
писать серверную часть программ на JavaScript.


## Как Node.js работает “под капотом”?

Событийная модель в Node.js
Каждый запрос клиента не блокируется
другими запросами.
* Выполнение кода происходит в одном потоке,
что позволяет не думать о параллельном
доступе к памяти
* Пока в рамках одного запроса приложение
делает запрос в БД или читает файл, Node.js
не простаивает и обрабатывает запросы
от других клиентов
* Такой подход не так требователен
к ресурсам железа

Чтобы разобраться с принципом работы Node.js, нужно понять, из чего он состоит.

*V8 — это среда, которая интерпретирует и компилирует JavaScript-код в машинный код. V8 также поддерживает возможности ECMAScript 6: классы,
стрелочные функции, промисы и другие. Такая среда исполнения работает в браузере Google Chrome и многих других.
* libUV — это библиотека на языке C, которая используется в Node.js для
обработки асинхронных операций ввода-вывода (I/O). Она отвечает за
предоставление асинхронных операций I/O и управление событийным
циклом.
* Менеджер пакетов NPM — это программа, которая позволяет устанавливать
и использовать дополнительные модули и библиотеки из общедоступного
репозитория. Об NPM мы подробно поговорим во второй лекции.

Контекст выполнения — это механизм, который позволяет интерпретатору
понимать, какие переменные и функции доступны для использования в текущий
момент.
Существует два контекста выполнения:
* Глобальный — создается при запуске скрипта. В него записываются все
переменные и функции, которые мы определим в скрипте.
* Контекст функции — создается во время вызова функции. В него
записываются переменные и функции, которые были определены внутри
исходной функции

Стек — это абстрактный тип данных, представляющий собой список элементов,
организованных по принципу LIFO (last in, first out), то есть последний добавленный
элемент будет первым удаленным. Чаще всего принцип работы стека сравнивают
со стопкой тарелок: есть стопка из трех тарелок, чтобы взять вторую, нужно сначала
взять третью.

Стек вызовов (call stack) — это механизм для отслеживания текущего контекста и
порядка вызовов функций. Каждый раз, когда функция вызывается, она
добавляется в стек вызовов. Когда функция завершается, она удаляется из стека
вызовов.


При запуске скрипта всегда создается глобальный контекст.
* Все объявленные переменные и функции в скрипте записываются в
глобальный контекст.
* Вызов функции создает новый контекст, и он добавляется в стек вызовов.
* Если в текущем контексте функции нет искомой переменной или функции,
интерпретатор ищет переменные и функции в контексте ниже по стеку.
* Для функций может быть создано столько контекстов, сколько позволяет
размер стека вызовов.

## Как связан интерпретатор V8 с библиотекой libUV?

В интернете часто говорят, что JavaScript выполняется в единственном потоке и не
имеет возможности параллельного выполнения кода. Это не совсем верно, так как
рассматривать JavaScript в отрыве от платформы, на которой он запускается,
некорректно.

Правильнее будет сказать, что движок, который интерпретирует JavaScript,
работает в одном потоке, но платформа, в рамках которой запускается движок,
позволяет достигнуть параллелизма в некоторых случаях, в том числе за счет
потоков.

В Node.js используется движок V8, и сам по себе он интерпретирует и выполняет
JavaScript-код в одном потоке выполнения. Это значит, что невозможно выполнить
две операции параллельно, код будет выполняться в том порядке, в котором был
написан, согласно правилам исполнения кода в JavaScript. Но в Node.js, помимо
самого движка V8, есть еще библиотека libUV.

```javascript 
setTimeout(() => {
  console.log('log in settimeout');
}, 1000);
console.log('log in global context');
```

При запуске скрипта с помощью Node.js инициализируется движок V8. В него
передаются разные переменные и функции, которые не являются частью
интерпретатора, такие как setTimeout. 

Когда мы вызываем setTimeout, мы передаем nв него два аргумента — колбек и время, через которое нужно вызвать
соответствующий колбек. Тут и происходит магия. Адрес колбека, который мы передаем, отправляется в libUV вместе с временем, через которое нужно вызвать этот колбек.

 Далее libUV инициализирует внутри себя таймер и постоянно
проверяет, не пришло ли время выполнить колбек. Как раз поэтому V8 свободен и
может выполнять код дальше, ведь таймер обрабатывается на стороне libUV.

1. При запуске скрипта инициализируется V8 и LibUV.
2. Далее начинается выполнение кода. Запускается функция setTimeout, ивызов функции добавляется в стек вызовов.
3. Как только функция setTimeout попадает в стек вызовов, происходит передача всех необходимых данных библиотеке libUV — это адрес колбека,
инициализированного в первом аргументе setTimeout(), и время таймера из второго аргумента.

4. Далее выполнение функции setTimeout завершается, и контекст функции извлекается из стека вызовов V8. Но что происходит в libUV? Здесь стоит
пояснить, что такое цикл событий. Цикл событий — это бесконечный цикл, который работает до тех пор, пока в
нем есть какие-либо задачи на выполнение. В нашем случае в цикл событий попадает таймер, и цикл на каждой итерации проверяет, достиг ли таймер
нужного времени.

<image src="./images/1.jpg">

5. После выполнения setTimeout на пятой строчке выполняется функция log()
глобального объекта console. Она добавляется в стек вызовов. Обратите внимание, что пока выполняется функция log(), в цикле событий содержится задача-таймер, которая еще не выполнилась, так как не пришло время.

6. После того как выполнится функция log() на пятой строчке, ее контекст
извлечется из стека событий. После этого в коде нечего выполнять. Но
Node.js не прекратит выполнение скрипта, так как есть зарегистрированная
задача в цикле событий. Что же произойдет, когда таймер достигнет нужного
времени? Адрес колбека передастся в очередь колбеков Callback Queue.
Очередь колеков нужна для того, чтобы хранить адреса функций, которые
нужно выполнить в интерпретаторе

<image src="./images/2.jpg">

7. После того как адрес колбека передастся в очередь колбеков, libUV проверит стек вызовов в V8. Если он окажется пустым (и только в этом случае), передаст в стек вызовов адрес функции, а V8 создаст для колбека контекст и начнет выполнять этот колбек.

<image src="./images/3.jpg">

8. Далее, так как в интерпретаторе была вызвана функция колбек, выполняется
тело этой функции и запускается функция log() глобального объекта console.
Эта функция добавляется в стек вызовов.

<image src="./images/4.jpg">

9. Когда выполнится функция log(), ее контекст извлечется из стека вызовов.

10. После этого, так как в колбеке больше нет кода, колбек также завершает свое выполнение и извлекается из стека вызовов.

Чтобы лучше понять работу Node.js, можно использовать
[Loupe](http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D) — инструмент визуализации работы v8 и цикла событий. 

<u>Важно знать, что Loupe не умеет работать со стрелочными функциями.</u>

***В браузере вместо libUV трудится библиотека WebAPI.***


## Резюмируя все, что мы разобрали касаемо работы Node.js, можем выделить важные тезисы:
* V8 работает в одном потоке, но libUV забирает на себя часть асинхронных задач, что позволяет не останавливать работу интерпретатора.
* Цикл событий в libUV — это бесконечный цикл, который работает до тех пор, пока есть задачи на выполнение и интерпретатор выполняет код.
* Помимо таймеров, libUV позволяет выполнять различные задачи: чтение и запись файлов, обработку сетевых запросов, запуск отдельных потоков и многое другое. Все это будет выполняться в рамках libUV, эти задачи не будут блокировать выполнение кода интерпретатором

## Установка Node.js

Зайдите на официальный сайт [nodejs](https://nodejs.org/en) и перейдите в раздел DOWNLOADS.

После установки Node.js его работоспособность можно проверить командой
`node -v` Эта команда позволяет узнать,
какая версия Node.js установлена на компьютере

## Способы запуска кода

Есть два способа запустить Javascript-код в Node.js — REPL и запуск файла с JS-кодом. Для начала разберемся, что такое REPL.

***REPL*** (Read-Eval-Print Loop) — это интерактивная оболочка для исполнения кода в Node.js в консоли. REPL позволяет вводить JavaScript-выражения и получать результат их выполнения.

Чтобы запустить REPL, нужно открыть терминал и ввести команду node без аргументов. Вы увидите приглашение к вводу, которое обозначается символом `>`
REPL сохраняет значения переменных в памяти, пока мы не закроем оболочку. Эти команды начинаются с символа `.` (точка). Например, если мы хотим посмотреть
список всех доступных команд, можем использовать команду `.help`

`Ctrl + D` выйти из режима REPL

В целом, режим REPL может подойти для написания простых скриптов, проверки маленького кусочка кода на работоспособность или для того, чтобы вспомнить, как работает та или иная конструкция языка

## Запуск JavaScript-файлов
Для запуска фалйа используем команду: `node nameFile.js`, где **nameFile.js** имя файла скрипта.

## Написание простого веб-сервера

1. Создаем файл `index.js`
2. Импортируем модуль HTTP с помощью функции
`require()`. Эта функция возвращает объект, который содержит функции и
объекты модуля HTTP
```javascript 
const http =require('http');
```
3.Создаем объект `server` с помощью функции
`http.createServer()`. Эта функция принимает в качестве аргумента функцию обратного вызова (callback), которая будет вызываться при каждом
HTTP-запросе к серверу. Эта функция обратного вызова получает два параметра: `req` и `res`. Параметр `req` представляет объект HTTP-запроса, а
параметр `res` представляет объект HTTP-ответа.

```javascript 
const server = http.createServer((req, res)=>{
    console.log('Запрос на сервер получен')
})
```
4. Указываем порт для запуска сервера с помощью
метода `server.listen()`. Этот метод принимает два аргумента: порт и функцию обратного вызова, которая будет вызываться при успешном запуске сервера.
```javascript
const port = 3000;
server.listen(port, ()=>{
    console.log(`Сервер запущен на порту: ${port}`)
})
```

5. Запускаем скрипт командой `node index.js`

Обратите внимание, что программа не завершает свое выполнение после запуска, как обычные JS-скрипты. Программа как бы зависает в бесконечном выполнении.
Все это происходит потому, что мы запустили HTTP-сервер и он должен постоянно ожидать запроса от клиентов, не должен завершаться, пока мы не захотим это сделать руками. Такое поведение обеспечивает libUV. Чтобы завершить скрипт, нужно вызвать функцию остановки сервера `.close()`, libUV перестанет слушать порт и выполнение скрипта остановится.

## Как отправлять HTTP-ответы с помощью объекта res?

Объект res в колбеке представляет HTTP-ответ, который мы можем отправить клиенту в ответ на его HTTP-запрос. У объекта res есть различные свойства и
методы, которые позволяют нам управлять содержимым и форматом ответа.

Метод `res.writeHead()` позволяет установить заголовки ответа — метаданные, которые передаются вместе с данными ответа и содержат информацию об их
типе, размере, кодировке и других характеристиках. Метод `res.writeHead()` принимает два аргумента:
* Код состояния (status code) — число, которое указывает на результат обработки запроса сервером. Например, код 200 означает успешный ответ, а код 404 — что запрашиваемый ресурс не найден.
* Объект заголовков (headers) — объект, который содержит пары ключ-значение, где ключ — это имя заголовка, а значение — это значение заголовка. Например, `{‘Content-Type’: ‘text/html’}` означает,
что тип данных ответа — это HTML-текст.

Метод `res.end()` позволяет завершить отправку ответа. Этот метод принимает один необязательный аргумент: данные (data).
* Данные — это строка или буфер, содержащие данные ответа, которые мы хотим отправить клиенту. Например, '\<h1>Hello world!\</h1>' означает, что мы хотим отправить HTML-текст с заголовком «Hello world!». Если мы не передаем аргумент `data` в метод `res.end()`, то мы отправляем пустой ответ

В теле колбека `createServer() ` допишем две строчки:

```javascript
res.writeHead(200, {'Content-Type': 'text/html; charset=UTF-8'});
res.end('<h1>Добро пожаловать на мой сайт </h1>')
```
В первом аргументе функции `res.writeHead()` мы указываем, какой код ответа будет на этот запрос. Вторым аргументом передаем объект заголовков, где указываем
единственный заголовок `Content-Type` со значением `text/html; charset=UTF-8.` Это нужно, чтобы указать браузеру, как правильно читать тело ответа.

Метод `res.end() `завершает выполнение запроса на наш сервер и принимает в качестве аргумента строку с данными, которые мы хотим вернуть.

Теперь, если мы запустим этот код и перейдем в браузере по адресу
`http://localhost:3000/`, то мы увидим страницу с заголовком «Добро пожаловать на мой сайт!».

## Как обрабатывать разные пути запроса?

Но что, если мы хотим сделать две разные страницы? Например:
1. `http://localhost:3000/home`
2. `http://localhost:3000/about`

Когда мы получаем запрос, и запускается наш обработчик запросов, мы всегда можем узнать, какой путь в адресной строке был передан. Пути в адресной строке еще называют `роутами`.

Финальный код будет выглядеть так:

```javascript 
const http =require('http');
const server =http.createServer((req, res)=>{
    console.log('Запрос получен');
    if (req.url ===='/home'){
        res.writeHead(
            200,
            {'Content-Type':'text/html; charset=UTF-8'}
        );
        res.end('<h1>Добро пожаловать на главную страницу</h1>')
    }
    else if(req.url==='/about'){
        res.writeHead(
            200,
            {'Content-Type':'text/html; charset=UTF-8'}
        );
        res.end('<h1>Добро пожаловать на  страницу о нас </h1>')
    }
});

const port =3000;
server.listen(port, ()=>{
    console.log('Сервер запущен')
})
```
Все, что мы сделали, — добавили два условных блока.
Объект запроса `req` имеет поле `url`, которое хранит строку со значением роута, который был передан во время запроса из браузера. Таким образом мы можем
обрабатывать любые роуты, в том числе роуты вида `/home/prices`, если, например,
нужно сделать подстраницу нашей главной страницы

## Как создать страницу 404?

Код `404` говорит о том, что искомой страницы на
ресурсе не существует. 
Добавим в блок `http.createServer` еще одну проверку:

```javascript 
else{
    res.writeHead(
        404,
        {'Content-Type':'text/html; charset=UTF-8'}
    );
    res.end('<h1>Страница не найдена </h1>')
}
```
**Дополнительные материалы**

* [Официальная документация Node.js](https://nodejs.org/docs/latest/api/)
* [Документация по модулю HTTP](https://nodejs.org/api/http.html)
* [Протокол HTTP](https://developer.mozilla.org/ru/docs/Web/HTTP/Overview)

# Лекция 2

## Что такое NPM?

NPM (Node Package Manager) – это менеджер пакетов для Node.js. Однако NPM не ограничивается только Node.js – вы можете использовать NPM для управления
пакетами для любого проекта на JavaScript.

NPM имеет множество преимуществ для разработчиков на JavaScript:

* Вы можете легко находить и использовать тысячи готовых решений для
разных задач, таких как работа с датами, строками, массивами, объектами,
HTTP запросами, базами данных и т. д.
* Вы можете контролировать версии пакетов, которые вы используете в своих
проектах, и избегать конфликтов и ошибок.
* Вы можете повышать качество и безопасность своего кода, используя пакеты
для тестирования, линтинга, форматирования, анализа и т. д.
* Вы можете делиться своими решениями с другими разработчиками и
получать обратную связь и поддержку

## Как установить NPM?

NPM является неотъемлемой частью Node.js. Поэтому, для того чтобы убедиться, что npm установлен, достаточно ввести в терминал следующую
команду `npm -v`

## Из чего состоит NPM?

NPM состоит из двух основных компонентов: **NPM registry** и **NPM CLI**.

**NPM registry**. Вы можете искать, просматривать и скачивать пакеты из npm registry с
помощью командной строки или браузера. Вы также можете опубликовать
собственные пакеты в npm registry и делиться ими с другими разработчиками. [сайт NPM] (https://www.npmjs.com/)

**NPM CLI** – это интерфейс командной строки для работы с NPM. С помощью NPM CLI
вы можете выполнять различные операции с пакетами, такие как установка,
удаление, обновление, просмотр информации и т. д.

## Как инициализировать проект npm?

Проект npm – это любая директория на вашем компьютере, которая содержит файл
`package.json`. Файл `package.json` – это специальный файл в формате JSON,
который содержит метаданные о вашем проекте, такие как имя, версия, описание,
автор, лицензия и т. д. Также в файле `package.json` указываются зависимости
вашего проекта, то есть пакеты, которые нужны для работы вашего кода.

Для того чтобы инициализировать NPM проект, вам нужно создать файл
`package.json`. Этот файл можно создать руками, но есть способ более простой,
можно запустить команду npm init в любом каталоге на вашем компьютере,
который вы хотите сделать проектом npm. Вам будет задано несколько вопросов о
вашем проекте, таких как имя, версия, описание, автор и т. д. Вы можете ответить
на них или пропустить нажатием Enter. По умолчанию будут использованы значения
из глобальных настроек npm.

После того как вы ответите на все вопросы или пропустите их, вам будет показано
содержимое файла `package.json`, который будет создан в вашем каталоге.

## Что хранится в файле package.json?
Такой JSON объект вы увидите в содержимом файла:

<image src="./images/5.jpg">

name – имя вашего пакета, которое должно быть уникальным в реестре npm.
Оно должно быть коротким, описательным и должно содержать в себе только
прописные буквы, дефисы и цифры;
* version – версия вашего пакета, которая должна следовать семантическому
версионированию. Она состоит из трёх чисел, разделённых точками:
основной версии, подверсии и номера исправления. О семантическом
версионировании мы поговорим немного позже;
* description – краткое описание вашего пакета, которое помогает
пользователям понять, что он делает и зачем он нужен. Оно должно быть
одним или двумя предложениями и не содержать HTML-тегов или
URL-адресов;
* main – эта строка указывает имя файла, который экспортирует основной
модуль вашего пакета. Это можно понимать, как точку входа в ваш проект. Об
этом поле мы более подробно поговорим немного позже;
* scripts – объект, содержащий скрипты проекта, которые могут быть
запущены с помощью команды npm run. Ключи являются названиями
скриптов, а значения – командами для запуска;
* author – объект или строка, которая указывает автора или создателя вашего
пакета. Если это объект, он может иметь три поля: name, email и url;
* license – эта строка указывает лицензию, под которой распространяется ваш
пакет. Можете пока не обращать внимания на значение лицензии, будем
использовать значение по умолчанию ISC.

 ## Пример установки пакета
Для примера установки возьмём пакет `uuid`. 

Пакет `uuid` позволяет генерировать уникальные идентификаторы. UUID – это строки из 36 символов, которые состоят из цифр и букв и имеют определённый формат

Для того чтобы установить пакет `uuid` в ваш проект, вам нужно выполнить команду
`npm install uuid`

Эта команда скачает пакет `uuid` из npm registry и добавит его в
ваш проект. Также эта команда обновит файл `package.json` и добавит пакет `uuid`
как ключ в раздел `dependencies`, а также запишет текущую версию пакета в качестве значения. Это означает, что пакет `uuid` является зависимостью вашего
проекта – то есть ваш код не может работать без него.

Обратите внимание, что версия пакета `uuid` в начале строки имеет специальный
символ `^`. Этот символ означает, что версию пакета необходимо обновлять. При выполенении команды `npm install uuid` пакет `uuid` будет обновлен, если его обновлять  не требуется нужно убрать символ `^`

Для того чтобы использовать пакет `uuid` в вашем коде, вам нужно создать новый
файл рядом с `package.json` и расширением `.js`. Например, `index.js` как указано
на пятой строке в файле package.json. После этого необходимо открыть файл в редакторе кода и вставить туда следующий
код:
```javascript
// Импортируем пакет uuid
const uuid=require('uuid');
//Генерируем uuid
const id =uuid.v4();
// Выводим сгенерированный ID 
console.log(id);
```

Теперь давайте немного разберём код. Для того чтобы использовать установленные
пакеты, необходимо в нашем скрипте получить доступ к этому коду. В Node.js можно
использовать функцию `require()`. В функцию нужно передать название пакета,
как в файле `package.json` в поле `dependencies`. 

Функция `require()` возвращает
экспортируемые методы и поля пакета `uuid`. Всё это можно записать в переменную
и использовать в коде.
В нашем примере мы записали в константу `uuid` объект с экспортируемыми
модулями и полями пакета `uuid`. Далее, для генерации уникального
идентификатора, мы вызвали функцию `.v4()` и получили результат в виде строки.
Для того чтобы запустить код, можно использовать Node.js. Для этого в консоли
выполните команду `node index.js`

после установки пакета `uuid`
в директории вашего проекта автоматически создалась директория `node_modules` и
файл `package-lock.json`
## Что такое node_modules и как он устроен?

**node_modules** – это каталог в вашем проекте npm, в котором хранятся все
установленные пакеты и их зависимости. Когда вы устанавливаете пакет с
помощью NPM, он скачивается из `npm registry` и размещается в каталоге
`node_modules`. Также в каталоге `node_modules` размещаются все пакеты, от которых
зависит установленный пакет.

Структура папки `node_modules` зависит от того, какая версия NPM используется для
установки пакетов. До третьей версии NPM использовал древовидную структуру, в
которой каждый пакет имел свою подпапку `node_modules` со своими
зависимостями. Это приводило к дублированию и избыточности файлов, а также к
проблемам с длиной пути файлов на некоторых операционных системах.

<image src="./images/6.jpg">

Начиная с третьей версии NPM стал использовать плоскую структуру, в которой все
зависимости устанавливаются на одном уровне в папке `node_modules`. Это
уменьшило количество файлов и длину пути файлов, а также упростило
разрешение конфликтов версий.

<image src="./images/7.jpg">

*Начиная с третьей версии NPM, если два пакета требуют разные версии
одной и той же зависимости, то NPM создаст подпапку node_modules для
одного из пакетов и установит туда нужную версию зависимости*

Каталог node_modules может быть очень большим и содержать много пакетов и
файлов, поэтому его не рекомендуется добавлять в систему контроля версий.

## Установка зависимостей проекта
чтобы запустить проект, необходимо установить все зависимости.
Для этого нужно выполнить две команды: `npm install` или `npm ci`
## Отличие npm install от npm ci

**npm install** (без указания конкретного пакета) создаёт директорию `node_modules` и
скачивает туда все зависимости, указанные в `package.json`, а также создаст файл
`package-lock.json`. Если `node_modules` и `package-lock.json` уже существуют, `npm
install` проверит, все ли пакеты, которые есть в `package.json`, есть в `node_modules` и
установит недостающие пакеты. Также важно понимать, что `npm install` обновит
пакеты, у которых в версии есть специальный символ `^` до более актуальных и
обновит информацию о версиях в `package-lock.json`. Если специальный символ `^` не
указан в версии пакета, то пакет обновлён не будет.

**npm ci** (clean install) так же как и `npm install`, создаст директорию `node_modules`,
если она отсутствует, но при этом версии пакетов будет сверять с файлом
`package-lock.json`, при этом версии пакетов npm ci не обновляет. Если директория
`node_modules` уже существует, то npm ci удалит её и создаст, заново скачав туда все
необходимые зависимости. Это более безопасный способ установки зависимостей,
так как иногда автоматическое обновление пакетов с помощью `npm install` может
привести к поломке вашего кода, если разработчики пакета допустили ошибку в
новой версии пакета, хотя такое происходит крайне редко.

## Удаление пакетов
NPM позволяет удалить установленный пакет, если он вам больше не нужен. Для
этого существует команда `npm uninstall <имя_пакета>`.

Эта команда удалит все файлы, связанные с пакетом, из `node_modules`, а также
удалит строку с названием и версией пакета из `package.json`.

Также вы можете удалить пакет, удалив в `package.json` строку с его упоминанием и
набрав в консоли команду `npm ci` или `npm install`. Эти команды удаляют из
`node_modules` любые пакеты, которые не упоминаются в `node_modules`.

## Что такое package-lock.json?

**package-lock.json**– это специальный файл, который создаётся и обновляется
автоматически при установке или обновлении пакетов npm. Этот файл содержит
точную информацию обо всех установленных пакетах в вашем проекте и их
зависимостях, включая номера версий, хеши и пути к файлам.

**package-lock.json** нужен, для того чтобы гарантировать, что вы и другие
разработчики, работающие с вашим проектом, используете одинаковые версии
пакетов и зависимостей. Это помогает избежать проблем с несовместимостью или
ошибками при запуске или развёртывании вашего проекта.

**package-lock.json** гарантирует, что если другой разработчик скачает ваш проект с Git
и установит зависимости с помощью команды npm ci, то все версии пакетов будут
такими же, какие и у вас.
Вы не должны редактировать файл `package-lock.json` вручную или удалять его
из вашего проекта. Вы должны добавить его в систему контроля версий, чтобы
сохранять его историю и синхронизировать его с другими разработчиками.

[официальная документация package.json](https://docs.npmjs.com/cli/v8/configuring-npm/package-lock-json)
## Что такое dependencies и devDependencies и в чём их различие?

 Ранее мы установили пакет `uuid`, и в `package.json` он добавился в объект `dependencies`. Но существует другой вариант установки пакета. Когда вы устанавливаете пакеты в ваш проект с помощью NPM, вы можете указать тип зависимости для каждого пакета: `dependencies` или `devDependencies`.

**dependencies** – это зависимости, которые необходимы для работы вашего кода в
продакшене – то есть когда вы запускаете или разворачиваете свой проект на
реальном сервере или клиенте. Например, если вы создаёте веб-приложение на
React, то React является зависимостью типа `dependencies`.

**devDependencies** – это зависимости, которые необходимы только для разработки
вашего кода – то есть когда вы пишете, тестируете или отлаживаете свой код на
локальном компьютере. Например, если вы используете Jest для тестирования
своего кода, то Jest является зависимостью типа `devDependencies`.

Разделение зависимостей на два типа помогает оптимизировать размер и скорость
вашего проекта в продакшене, так как вам не нужно устанавливать и загружать
лишние пакеты, которые не используются в продакшн среде.

Для того чтобы установить пакет как зависимость типа dependencies, вы должны
использовать команду `npm install <package-name>` без дополнительных
флагов. Для того чтобы установить пакет как зависимость типа devDependencies, вы
можете использовать команду `npm install <package-name> --save-dev` или
`npm install <package-name> -D`.

## Что такое скрипты NPM?

Вы можете заметить, что в `package.json` есть поле `scripts`. Сюда вы можете помещать различные скрипты, которые вам помогут в разработке.

Скрипты NPM – это способ автоматизировать различные задачи, связанные с вашим
проектом. Вы можете запускать скрипты npm с помощью команды `npm run <script-name>` в командной строке, где `<script-name>` – это название вашего скрипта. Названием скрипта является само поле в объекте `scripts`.

Скрипты npm могут выполнять различные действия, такие как компиляция, форматирование, проверка, тестирование, сборка или публикация вашего кода.

Также вы могли заметить, что в `scripts` есть поле `test` – это тестовый скрипт,
который создаётся по умолчанию в проекте npm. Если запустите этот скрипт `npm run test`, то увидите сообщение в консоли *Error: no test specified*. Базово
этот скрипт нужен для указания команды на запуск тестов. 

## Экспорт из модулей
Экспорт функций и переменных в node.js позволяет использовать их в других
файлах или модулях, позволяя повторно использовать код и упрощая отладку и
поддержку приложения.

Для экспорта функций и переменных в node.js нужно использовать объект
`module.exports`, который является свойством глобального объекта `module`. Этот
объект содержит всё то, что будет доступно для импорта в других файлах или
модулях.

Cоздадим файл в нашем проекте и назовём его math.js добавим туда две функции: `add()` – функция сложения чисел и `subtract()`
```javascript
//math.js
function add(a,b){
    return a + b;
}
function subtract(a,b){
    return a - b;
}
module.exports= {add, subtract}
```

Для импорта функций и переменных в node.js нужно использовать уже знакомую
вам функцию `require()`. Она принимает путь к файлу или модулю, из которого
нужно импортировать. Эта функция возвращает объект с импортированными
данными, который можно сохранить в переменной и использовать для вызова
функций или доступа к переменным.

Например, если мы хотим импортировать функции add и subtract из файла
`math.js` в файл `index.js`, мы можем сделать следующее:
```javascript
//index.js
const math =require('./math')

const result = math.add(3,5);
console.log(result)

const result = math.subtract(3,5);
console.log(result)
```
Обратите внимание на два вызова функции `require()`.
В первом случае `require('uuid')` нет необходимости указывать
относительность пути, то есть добавлять `./` или `../` , так как это
установленный npm пакет.

Во втором случае также можно не указывать относительность пути `./` ,
если файл находится в той же директории, в которой мы импортируем модуль, но следует помнить, что если файл будет находиться в другой директории, например, `libs` , то нам нужно будет вызвать require следующим образом: `require(’./libs/math.js’)`. Для того чтобы не путать локальные файлы с установленными пакетами, рекомендуется всегда указывать относительность пути, как в примере с кодом:
`require(’./math’);`

## Как создать собственный пакет?
Для этого нужно зайти на [официальный сайт NPM] (https://www.npmjs.com/) и в строке поиска ввести любое название пакета, которое вам необходимо. Например, если ввести слово `math`, то мы увидим ряд пакетов, которые содержат в названии, в описании, либо в тегах слово `math`. Нужно придумать название пакета которое свободно.

Теперь давайте создадим новый `npm` проект. Инициализируем проект `npm init -y`

Создадим файл `math.js` и заполним его следующим кодом:
```javascript
//math.js
function add(a,b){
    return a + b;
}
function subtract(a,b){
    return a - b;
}
module.exports= {add, subtract}
```
Также необходимо рядом с `package.json` создать файл `README.md` с описанием
проекта. Это описание будет использоваться на сайте `npm`.

Теперь необходимо подготовить файл package.json

Нужно придумать название нашего пакета и написать в поле `name`. Оно
должно быть уникально в рамках `npm registry`. Проверить уникальность
достаточно просто: нужно зайти на официальный сайт NPM и в поисковой
строке поискать по названию, которое вы хотите дать своему пакету, другие
пакеты с таким же названием. Если поиск не дал результатов – это означает,
что имя не занято и его можно использовать.
* Также нужно добавить описание нашего пакета в поле `description`
* И ещё не забываем указать себя в качестве автора пакета в поле `author`
* Теперь обратите внимание на поле `main` . В этом поле хранится путь до
файла, который будет использован, как файл для импорта.  То есть пользователи, скачавшие ваш пакет, когда в `require()` укажут название вашего пакета, получат результатом выполнения функции `require()` значение, которое экспортируется из модуля. В нашем случае необходимо заменить `index.js` на `math.js`

Теперь публикуем! Для этого необходимо проделать некоторые действия:
* Создайте аккаунт на [NPM](https://www.npmjs.com/) или войдите в свой
существующий аккаунт.
* Подтвердите свой адрес электронной почты.
* В терминале авторизуйтесь в `npm registry` с помощью команды `npm login`.
Эта команда отправит вас в браузер и попросит ввести код из письма на
почте.
* Опубликуйте ваш пакет в` npm registry` с помощью команды `npm publish`
* Проверьте, что ваш пакет появился на сайте [NPM](https://www.npmjs.com/) и
доступен для установки и использования.

Теперь можно устанавливать этот пакет и переиспользовать его код в любом
проекте! Достаточно установить его `npm install name_your_package`.

## Что такое семантическое версионирование?

Давайте теперь разберёмся, как работают версии пакетов в проекте. Для
версионирования пакетов используется семантическое версионирование.

Семантическое версионирование – это система правил и соглашений для
присвоения номеров версий пакетам. Семантическое версионирование помогает
разработчикам понимать, какие изменения произошли в пакете при обновлении его
версии, и как эти изменения могут повлиять на совместимость с другими пакетами.

Семантическое версионирование использует следующий формат для номеров
версий: `major.minor.patch`.
Где:
* **major** – это мажорная версия, которая увеличивается, когда в пакете
происходят серьёзные изменения, которые ломают обратную совместимость
с предыдущими версиями. Например, если в пакете изменяется API,
удаляются функции или меняются зависимости.
* **minor** – это минорная версия, которая увеличивается, когда в пакете
добавляются новые функции или улучшения, которые не ломают обратную
совместимость с предыдущими версиями. Например, если в пакете
добавляются новые опции, параметры или методы.
* **patch** – это патч-версия, которая увеличивается, когда в пакете исправляются
ошибки или баги, которые не влияют на функциональность или
совместимость с предыдущими версиями. Например, если в пакете
исправляются опечатки, улучшается производительность или безопасность.

При изменении более старшей версии, более младшие обнуляются. Например, если
у нас есть версия `2.5.2`и увеличивается минорная версия, то получится `2.6.0`, то
есть патч версия обнулилась.

## Какие ещё есть команды для npm cli?

* `npm help` или `npm h` – выводит справочную информацию о командах `npm cli`;
* `npm uninstall <package-name>` или `npm un <package-name>` – удаляет
пакет из вашего проекта и из файла `package.json`;
* `npm list` или `npm ls` – выводит список всех установленных пакетов в
вашем проекте и их версии;
* `npm view <package-name>` или `npm v <package-name>` – выводит
информацию о пакете из `npm registry`, такую как имя, описание, версия,
лицензия, зависимости и т. д.;
* `npm search <keyword>` или `npm s <keyword>` – ищет пакеты в `npm registry`
по ключевому слову и выводит их названия и описания.
* `npm repo <package-name>` выводит ссылку на репозиторий git проекта

Полный список команд можно посмотреть здесь [NPM](https://docs.npmjs.com/cli/v7/commands)

**Дополнительные материалы**
Официальная документация [NPM](https://docs.npmjs.com/), где вы найдете
подробные инструкции и примеры по использованию NPM и его команд.
● Полное описание правил семантического версионирования https://semver.org/lang/ru/