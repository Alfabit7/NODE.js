# Урок 1
Предпосылки к созданию Node.js

## Что такое Node.js?
Раян Даль - Американский инженер-программист cоздатель Node.js
`Node.js` — это платформа, которая позволяет разработчикам
писать серверную часть программ на JavaScript.


## Как Node.js работает “под капотом”?

Событийная модель в Node.js
Каждый запрос клиента не блокируется
другими запросами.
* Выполнение кода происходит в одном потоке,
что позволяет не думать о параллельном
доступе к памяти
* Пока в рамках одного запроса приложение
делает запрос в БД или читает файл, Node.js
не простаивает и обрабатывает запросы
от других клиентов
* Такой подход не так требователен
к ресурсам железа

Чтобы разобраться с принципом работы Node.js, нужно понять, из чего он состоит.

*V8 — это среда, которая интерпретирует и компилирует JavaScript-код в машинный код. V8 также поддерживает возможности ECMAScript 6: классы,
стрелочные функции, промисы и другие. Такая среда исполнения работает в браузере Google Chrome и многих других.
* libUV — это библиотека на языке C, которая используется в Node.js для
обработки асинхронных операций ввода-вывода (I/O). Она отвечает за
предоставление асинхронных операций I/O и управление событийным
циклом.
* Менеджер пакетов NPM — это программа, которая позволяет устанавливать
и использовать дополнительные модули и библиотеки из общедоступного
репозитория. Об NPM мы подробно поговорим во второй лекции.

Контекст выполнения — это механизм, который позволяет интерпретатору
понимать, какие переменные и функции доступны для использования в текущий
момент.
Существует два контекста выполнения:
* Глобальный — создается при запуске скрипта. В него записываются все
переменные и функции, которые мы определим в скрипте.
* Контекст функции — создается во время вызова функции. В него
записываются переменные и функции, которые были определены внутри
исходной функции

Стек — это абстрактный тип данных, представляющий собой список элементов,
организованных по принципу LIFO (last in, first out), то есть последний добавленный
элемент будет первым удаленным. Чаще всего принцип работы стека сравнивают
со стопкой тарелок: есть стопка из трех тарелок, чтобы взять вторую, нужно сначала
взять третью.

Стек вызовов (call stack) — это механизм для отслеживания текущего контекста и
порядка вызовов функций. Каждый раз, когда функция вызывается, она
добавляется в стек вызовов. Когда функция завершается, она удаляется из стека
вызовов.


При запуске скрипта всегда создается глобальный контекст.
* Все объявленные переменные и функции в скрипте записываются в
глобальный контекст.
* Вызов функции создает новый контекст, и он добавляется в стек вызовов.
* Если в текущем контексте функции нет искомой переменной или функции,
интерпретатор ищет переменные и функции в контексте ниже по стеку.
* Для функций может быть создано столько контекстов, сколько позволяет
размер стека вызовов.

## Как связан интерпретатор V8 с библиотекой libUV?

В интернете часто говорят, что JavaScript выполняется в единственном потоке и не
имеет возможности параллельного выполнения кода. Это не совсем верно, так как
рассматривать JavaScript в отрыве от платформы, на которой он запускается,
некорректно.

Правильнее будет сказать, что движок, который интерпретирует JavaScript,
работает в одном потоке, но платформа, в рамках которой запускается движок,
позволяет достигнуть параллелизма в некоторых случаях, в том числе за счет
потоков.

В Node.js используется движок V8, и сам по себе он интерпретирует и выполняет
JavaScript-код в одном потоке выполнения. Это значит, что невозможно выполнить
две операции параллельно, код будет выполняться в том порядке, в котором был
написан, согласно правилам исполнения кода в JavaScript. Но в Node.js, помимо
самого движка V8, есть еще библиотека libUV.

```javascript 
setTimeout(() => {
  console.log('log in settimeout');
}, 1000);
console.log('log in global context');
```

При запуске скрипта с помощью Node.js инициализируется движок V8. В него
передаются разные переменные и функции, которые не являются частью
интерпретатора, такие как setTimeout. 

Когда мы вызываем setTimeout, мы передаем nв него два аргумента — колбек и время, через которое нужно вызвать
соответствующий колбек. Тут и происходит магия. Адрес колбека, который мы передаем, отправляется в libUV вместе с временем, через которое нужно вызвать этот колбек.

 Далее libUV инициализирует внутри себя таймер и постоянно
проверяет, не пришло ли время выполнить колбек. Как раз поэтому V8 свободен и
может выполнять код дальше, ведь таймер обрабатывается на стороне libUV.

1. При запуске скрипта инициализируется V8 и LibUV.
2. Далее начинается выполнение кода. Запускается функция setTimeout, ивызов функции добавляется в стек вызовов.
3. Как только функция setTimeout попадает в стек вызовов, происходит передача всех необходимых данных библиотеке libUV — это адрес колбека,
инициализированного в первом аргументе setTimeout(), и время таймера из второго аргумента.

4. Далее выполнение функции setTimeout завершается, и контекст функции извлекается из стека вызовов V8. Но что происходит в libUV? Здесь стоит
пояснить, что такое цикл событий. Цикл событий — это бесконечный цикл, который работает до тех пор, пока в
нем есть какие-либо задачи на выполнение. В нашем случае в цикл событий попадает таймер, и цикл на каждой итерации проверяет, достиг ли таймер
нужного времени.

<image src="./images/1.jpg">

5. После выполнения setTimeout на пятой строчке выполняется функция log()
глобального объекта console. Она добавляется в стек вызовов. Обратите внимание, что пока выполняется функция log(), в цикле событий содержится задача-таймер, которая еще не выполнилась, так как не пришло время.

6. После того как выполнится функция log() на пятой строчке, ее контекст
извлечется из стека событий. После этого в коде нечего выполнять. Но
Node.js не прекратит выполнение скрипта, так как есть зарегистрированная
задача в цикле событий. Что же произойдет, когда таймер достигнет нужного
времени? Адрес колбека передастся в очередь колбеков Callback Queue.
Очередь колеков нужна для того, чтобы хранить адреса функций, которые
нужно выполнить в интерпретаторе

<image src="./images/2.jpg">

7. После того как адрес колбека передастся в очередь колбеков, libUV проверит стек вызовов в V8. Если он окажется пустым (и только в этом случае), передаст в стек вызовов адрес функции, а V8 создаст для колбека контекст и начнет выполнять этот колбек.

<image src="./images/3.jpg">

8. Далее, так как в интерпретаторе была вызвана функция колбек, выполняется
тело этой функции и запускается функция log() глобального объекта console.
Эта функция добавляется в стек вызовов.

<image src="./images/4.jpg">

9. Когда выполнится функция log(), ее контекст извлечется из стека вызовов.

10. После этого, так как в колбеке больше нет кода, колбек также завершает свое выполнение и извлекается из стека вызовов.

Чтобы лучше понять работу Node.js, можно использовать
[Loupe](http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D) — инструмент визуализации работы v8 и цикла событий. 

<u>Важно знать, что Loupe не умеет работать со стрелочными функциями.</u>

***В браузере вместо libUV трудится библиотека WebAPI.***


## Резюмируя все, что мы разобрали касаемо работы Node.js, можем выделить важные тезисы:
* V8 работает в одном потоке, но libUV забирает на себя часть асинхронных задач, что позволяет не останавливать работу интерпретатора.
* Цикл событий в libUV — это бесконечный цикл, который работает до тех пор, пока есть задачи на выполнение и интерпретатор выполняет код.
* Помимо таймеров, libUV позволяет выполнять различные задачи: чтение и запись файлов, обработку сетевых запросов, запуск отдельных потоков и многое другое. Все это будет выполняться в рамках libUV, эти задачи не будут блокировать выполнение кода интерпретатором

## Установка Node.js

Зайдите на официальный сайт [nodejs](https://nodejs.org/en) и перейдите в раздел DOWNLOADS.

После установки Node.js его работоспособность можно проверить командой
`node -v` Эта команда позволяет узнать,
какая версия Node.js установлена на компьютере

## Способы запуска кода

Есть два способа запустить Javascript-код в Node.js — REPL и запуск файла с JS-кодом. Для начала разберемся, что такое REPL.

***REPL*** (Read-Eval-Print Loop) — это интерактивная оболочка для исполнения кода в Node.js в консоли. REPL позволяет вводить JavaScript-выражения и получать результат их выполнения.

Чтобы запустить REPL, нужно открыть терминал и ввести команду node без аргументов. Вы увидите приглашение к вводу, которое обозначается символом `>`
REPL сохраняет значения переменных в памяти, пока мы не закроем оболочку. Эти команды начинаются с символа `.` (точка). Например, если мы хотим посмотреть
список всех доступных команд, можем использовать команду `.help`

`Ctrl + D` выйти из режима REPL

В целом, режим REPL может подойти для написания простых скриптов, проверки маленького кусочка кода на работоспособность или для того, чтобы вспомнить, как работает та или иная конструкция языка

## Запуск JavaScript-файлов
Для запуска фалйа используем команду: `node nameFile.js`, где **nameFile.js** имя файла скрипта.

## Написание простого веб-сервера

1. Создаем файл `index.js`
2. Импортируем модуль HTTP с помощью функции
`require()`. Эта функция возвращает объект, который содержит функции и
объекты модуля HTTP
```javascript 
const http =require('http');
```
3.Создаем объект `server` с помощью функции
`http.createServer()`. Эта функция принимает в качестве аргумента функцию обратного вызова (callback), которая будет вызываться при каждом
HTTP-запросе к серверу. Эта функция обратного вызова получает два параметра: `req` и `res`. Параметр `req` представляет объект HTTP-запроса, а
параметр `res` представляет объект HTTP-ответа.

```javascript 
const server = http.createServer((req, res)=>{
    console.log('Запрос на сервер получен')
})
```
4. Указываем порт для запуска сервера с помощью
метода `server.listen()`. Этот метод принимает два аргумента: порт и функцию обратного вызова, которая будет вызываться при успешном запуске сервера.
```javascript
const port = 3000;
server.listen(port, ()=>{
    console.log(`Сервер запущен на порту: ${port}`)
})
```

5. Запускаем скрипт командой `node index.js`

Обратите внимание, что программа не завершает свое выполнение после запуска, как обычные JS-скрипты. Программа как бы зависает в бесконечном выполнении.
Все это происходит потому, что мы запустили HTTP-сервер и он должен постоянно ожидать запроса от клиентов, не должен завершаться, пока мы не захотим это сделать руками. Такое поведение обеспечивает libUV. Чтобы завершить скрипт, нужно вызвать функцию остановки сервера `.close()`, libUV перестанет слушать порт и выполнение скрипта остановится.

## Как отправлять HTTP-ответы с помощью объекта res?

Объект res в колбеке представляет HTTP-ответ, который мы можем отправить клиенту в ответ на его HTTP-запрос. У объекта res есть различные свойства и
методы, которые позволяют нам управлять содержимым и форматом ответа.

Метод `res.writeHead()` позволяет установить заголовки ответа — метаданные, которые передаются вместе с данными ответа и содержат информацию об их
типе, размере, кодировке и других характеристиках. Метод `res.writeHead()` принимает два аргумента:
* Код состояния (status code) — число, которое указывает на результат обработки запроса сервером. Например, код 200 означает успешный ответ, а код 404 — что запрашиваемый ресурс не найден.
* Объект заголовков (headers) — объект, который содержит пары ключ-значение, где ключ — это имя заголовка, а значение — это значение заголовка. Например, `{‘Content-Type’: ‘text/html’}` означает,
что тип данных ответа — это HTML-текст.

Метод `res.end()` позволяет завершить отправку ответа. Этот метод принимает один необязательный аргумент: данные (data).
* Данные — это строка или буфер, содержащие данные ответа, которые мы хотим отправить клиенту. Например, '\<h1>Hello world!\</h1>' означает, что мы хотим отправить HTML-текст с заголовком «Hello world!». Если мы не передаем аргумент `data` в метод `res.end()`, то мы отправляем пустой ответ

В теле колбека `createServer() ` допишем две строчки:

```javascript
res.writeHead(200, {'Content-Type': 'text/html; charset=UTF-8'});
res.end('<h1>Добро пожаловать на мой сайт </h1>')
```
В первом аргументе функции `res.writeHead()` мы указываем, какой код ответа будет на этот запрос. Вторым аргументом передаем объект заголовков, где указываем
единственный заголовок `Content-Type` со значением `text/html; charset=UTF-8.` Это нужно, чтобы указать браузеру, как правильно читать тело ответа.

Метод `res.end() `завершает выполнение запроса на наш сервер и принимает в качестве аргумента строку с данными, которые мы хотим вернуть.

Теперь, если мы запустим этот код и перейдем в браузере по адресу
`http://localhost:3000/`, то мы увидим страницу с заголовком «Добро пожаловать на мой сайт!».

## Как обрабатывать разные пути запроса?

Но что, если мы хотим сделать две разные страницы? Например:
1. `http://localhost:3000/home`
2. `http://localhost:3000/about`

Когда мы получаем запрос, и запускается наш обработчик запросов, мы всегда можем узнать, какой путь в адресной строке был передан. Пути в адресной строке еще называют `роутами`.

Финальный код будет выглядеть так:

```javascript 
const http =require('http');
const server =http.createServer((req, res)=>{
    console.log('Запрос получен');
    if (req.url ===='/home'){
        res.writeHead(
            200,
            {'Content-Type':'text/html; charset=UTF-8'}
        );
        res.end('<h1>Добро пожаловать на главную страницу</h1>')
    }
    else if(req.url==='/about'){
        res.writeHead(
            200,
            {'Content-Type':'text/html; charset=UTF-8'}
        );
        res.end('<h1>Добро пожаловать на  страницу о нас </h1>')
    }
});

const port =3000;
server.listen(port, ()=>{
    console.log('Сервер запущен')
})
```
Все, что мы сделали, — добавили два условных блока.
Объект запроса `req` имеет поле `url`, которое хранит строку со значением роута, который был передан во время запроса из браузера. Таким образом мы можем
обрабатывать любые роуты, в том числе роуты вида `/home/prices`, если, например,
нужно сделать подстраницу нашей главной страницы

## Как создать страницу 404?

Код `404` говорит о том, что искомой страницы на
ресурсе не существует. 
Добавим в блок `http.createServer` еще одну проверку:

```javascript 
else{
    res.writeHead(
        404,
        {'Content-Type':'text/html; charset=UTF-8'}
    );
    res.end('<h1>Страница не найдена </h1>')
}
```
**Дополнительные материалы**

* [Официальная документация Node.js](https://nodejs.org/docs/latest/api/)
* [Документация по модулю HTTP](https://nodejs.org/api/http.html)
* [Протокол HTTP](https://developer.mozilla.org/ru/docs/Web/HTTP/Overview)

# Урок 2
* Что такое пакетный менеджер NPM?
* Инициализация проекта NPM
* Пример установки пакета
* Что такое package.json, package-lock.json
* node_modules?
* Создание и публикация собственного пакета
* Семантическое версионирование
## Что такое NPM?

NPM (Node Package Manager) – это менеджер пакетов для Node.js. Однако NPM не ограничивается только Node.js – вы можете использовать NPM для управления
пакетами для любого проекта на JavaScript.

NPM имеет множество преимуществ для разработчиков на JavaScript:

* Вы можете легко находить и использовать тысячи готовых решений для
разных задач, таких как работа с датами, строками, массивами, объектами,
HTTP запросами, базами данных и т. д.
* Вы можете контролировать версии пакетов, которые вы используете в своих
проектах, и избегать конфликтов и ошибок.
* Вы можете повышать качество и безопасность своего кода, используя пакеты
для тестирования, линтинга, форматирования, анализа и т. д.
* Вы можете делиться своими решениями с другими разработчиками и
получать обратную связь и поддержку

## Как установить NPM?

NPM является неотъемлемой частью Node.js. Поэтому, для того чтобы убедиться, что npm установлен, достаточно ввести в терминал следующую
команду `npm -v`

## Из чего состоит NPM?

NPM состоит из двух основных компонентов: **NPM registry** и **NPM CLI**.

**NPM registry**. Вы можете искать, просматривать и скачивать пакеты из npm registry с
помощью командной строки или браузера. Вы также можете опубликовать
собственные пакеты в npm registry и делиться ими с другими разработчиками. [сайт NPM] (https://www.npmjs.com/)

**NPM CLI** – это интерфейс командной строки для работы с NPM. С помощью NPM CLI
вы можете выполнять различные операции с пакетами, такие как установка,
удаление, обновление, просмотр информации и т. д.

## Как инициализировать проект npm?

Проект npm – это любая директория на вашем компьютере, которая содержит файл
`package.json`. Файл `package.json` – это специальный файл в формате JSON,
который содержит метаданные о вашем проекте, такие как имя, версия, описание,
автор, лицензия и т. д. Также в файле `package.json` указываются зависимости
вашего проекта, то есть пакеты, которые нужны для работы вашего кода.

Для того чтобы инициализировать NPM проект, вам нужно создать файл
`package.json`. Этот файл можно создать руками, но есть способ более простой,
можно запустить команду npm init в любом каталоге на вашем компьютере,
который вы хотите сделать проектом npm. Вам будет задано несколько вопросов о
вашем проекте, таких как имя, версия, описание, автор и т. д. Вы можете ответить
на них или пропустить нажатием Enter. По умолчанию будут использованы значения
из глобальных настроек npm.

После того как вы ответите на все вопросы или пропустите их, вам будет показано
содержимое файла `package.json`, который будет создан в вашем каталоге.

## Что хранится в файле package.json?
Такой JSON объект вы увидите в содержимом файла:

<image src="./images/5.jpg">

name – имя вашего пакета, которое должно быть уникальным в реестре npm.
Оно должно быть коротким, описательным и должно содержать в себе только
прописные буквы, дефисы и цифры;
* version – версия вашего пакета, которая должна следовать семантическому
версионированию. Она состоит из трёх чисел, разделённых точками:
основной версии, подверсии и номера исправления. О семантическом
версионировании мы поговорим немного позже;
* description – краткое описание вашего пакета, которое помогает
пользователям понять, что он делает и зачем он нужен. Оно должно быть
одним или двумя предложениями и не содержать HTML-тегов или
URL-адресов;
* main – эта строка указывает имя файла, который экспортирует основной
модуль вашего пакета. Это можно понимать, как точку входа в ваш проект. Об
этом поле мы более подробно поговорим немного позже;
* scripts – объект, содержащий скрипты проекта, которые могут быть
запущены с помощью команды npm run. Ключи являются названиями
скриптов, а значения – командами для запуска;
* author – объект или строка, которая указывает автора или создателя вашего
пакета. Если это объект, он может иметь три поля: name, email и url;
* license – эта строка указывает лицензию, под которой распространяется ваш
пакет. Можете пока не обращать внимания на значение лицензии, будем
использовать значение по умолчанию ISC.

 ## Пример установки пакета
Для примера установки возьмём пакет `uuid`. 

Пакет `uuid` позволяет генерировать уникальные идентификаторы. UUID – это строки из 36 символов, которые состоят из цифр и букв и имеют определённый формат

Для того чтобы установить пакет `uuid` в ваш проект, вам нужно выполнить команду
`npm install uuid`

Эта команда скачает пакет `uuid` из npm registry и добавит его в
ваш проект. Также эта команда обновит файл `package.json` и добавит пакет `uuid`
как ключ в раздел `dependencies`, а также запишет текущую версию пакета в качестве значения. Это означает, что пакет `uuid` является зависимостью вашего
проекта – то есть ваш код не может работать без него.

Обратите внимание, что версия пакета `uuid` в начале строки имеет специальный
символ `^`. Этот символ означает, что версию пакета необходимо обновлять. При выполенении команды `npm install uuid` пакет `uuid` будет обновлен, если его обновлять  не требуется нужно убрать символ `^`

Для того чтобы использовать пакет `uuid` в вашем коде, вам нужно создать новый
файл рядом с `package.json` и расширением `.js`. Например, `index.js` как указано
на пятой строке в файле package.json. После этого необходимо открыть файл в редакторе кода и вставить туда следующий
код:
```javascript
// Импортируем пакет uuid
const uuid=require('uuid');
//Генерируем uuid
const id =uuid.v4();
// Выводим сгенерированный ID 
console.log(id);
```

Теперь давайте немного разберём код. Для того чтобы использовать установленные
пакеты, необходимо в нашем скрипте получить доступ к этому коду. В Node.js можно
использовать функцию `require()`. В функцию нужно передать название пакета,
как в файле `package.json` в поле `dependencies`. 

Функция `require()` возвращает
экспортируемые методы и поля пакета `uuid`. Всё это можно записать в переменную
и использовать в коде.
В нашем примере мы записали в константу `uuid` объект с экспортируемыми
модулями и полями пакета `uuid`. Далее, для генерации уникального
идентификатора, мы вызвали функцию `.v4()` и получили результат в виде строки.
Для того чтобы запустить код, можно использовать Node.js. Для этого в консоли
выполните команду `node index.js`

после установки пакета `uuid`
в директории вашего проекта автоматически создалась директория `node_modules` и
файл `package-lock.json`
## Что такое node_modules и как он устроен?

**node_modules** – это каталог в вашем проекте npm, в котором хранятся все
установленные пакеты и их зависимости. Когда вы устанавливаете пакет с
помощью NPM, он скачивается из `npm registry` и размещается в каталоге
`node_modules`. Также в каталоге `node_modules` размещаются все пакеты, от которых
зависит установленный пакет.

Структура папки `node_modules` зависит от того, какая версия NPM используется для
установки пакетов. До третьей версии NPM использовал древовидную структуру, в
которой каждый пакет имел свою подпапку `node_modules` со своими
зависимостями. Это приводило к дублированию и избыточности файлов, а также к
проблемам с длиной пути файлов на некоторых операционных системах.

<image src="./images/6.jpg">

Начиная с третьей версии NPM стал использовать плоскую структуру, в которой все
зависимости устанавливаются на одном уровне в папке `node_modules`. Это
уменьшило количество файлов и длину пути файлов, а также упростило
разрешение конфликтов версий.

<image src="./images/7.jpg">

*Начиная с третьей версии NPM, если два пакета требуют разные версии
одной и той же зависимости, то NPM создаст подпапку node_modules для
одного из пакетов и установит туда нужную версию зависимости*

Каталог node_modules может быть очень большим и содержать много пакетов и
файлов, поэтому его не рекомендуется добавлять в систему контроля версий.

## Установка зависимостей проекта
чтобы запустить проект, необходимо установить все зависимости.
Для этого нужно выполнить две команды: `npm install` или `npm ci`
## Отличие npm install от npm ci

**npm install** (без указания конкретного пакета) создаёт директорию `node_modules` и
скачивает туда все зависимости, указанные в `package.json`, а также создаст файл
`package-lock.json`. Если `node_modules` и `package-lock.json` уже существуют, `npm
install` проверит, все ли пакеты, которые есть в `package.json`, есть в `node_modules` и
установит недостающие пакеты. Также важно понимать, что `npm install` обновит
пакеты, у которых в версии есть специальный символ `^` до более актуальных и
обновит информацию о версиях в `package-lock.json`. Если специальный символ `^` не
указан в версии пакета, то пакет обновлён не будет.

**npm ci** (clean install) так же как и `npm install`, создаст директорию `node_modules`,
если она отсутствует, но при этом версии пакетов будет сверять с файлом
`package-lock.json`, при этом версии пакетов npm ci не обновляет. Если директория
`node_modules` уже существует, то npm ci удалит её и создаст, заново скачав туда все
необходимые зависимости. Это более безопасный способ установки зависимостей,
так как иногда автоматическое обновление пакетов с помощью `npm install` может
привести к поломке вашего кода, если разработчики пакета допустили ошибку в
новой версии пакета, хотя такое происходит крайне редко.

## Удаление пакетов
NPM позволяет удалить установленный пакет, если он вам больше не нужен. Для
этого существует команда `npm uninstall <имя_пакета>`.

Эта команда удалит все файлы, связанные с пакетом, из `node_modules`, а также
удалит строку с названием и версией пакета из `package.json`.

Также вы можете удалить пакет, удалив в `package.json` строку с его упоминанием и
набрав в консоли команду `npm ci` или `npm install`. Эти команды удаляют из
`node_modules` любые пакеты, которые не упоминаются в `node_modules`.

## Что такое package-lock.json?

**package-lock.json**– это специальный файл, который создаётся и обновляется
автоматически при установке или обновлении пакетов npm. Этот файл содержит
точную информацию обо всех установленных пакетах в вашем проекте и их
зависимостях, включая номера версий, хеши и пути к файлам.

**package-lock.json** нужен, для того чтобы гарантировать, что вы и другие
разработчики, работающие с вашим проектом, используете одинаковые версии
пакетов и зависимостей. Это помогает избежать проблем с несовместимостью или
ошибками при запуске или развёртывании вашего проекта.

**package-lock.json** гарантирует, что если другой разработчик скачает ваш проект с Git
и установит зависимости с помощью команды npm ci, то все версии пакетов будут
такими же, какие и у вас.
Вы не должны редактировать файл `package-lock.json` вручную или удалять его
из вашего проекта. Вы должны добавить его в систему контроля версий, чтобы
сохранять его историю и синхронизировать его с другими разработчиками.

[официальная документация package.json](https://docs.npmjs.com/cli/v8/configuring-npm/package-lock-json)
## Что такое dependencies и devDependencies и в чём их различие?

 Ранее мы установили пакет `uuid`, и в `package.json` он добавился в объект `dependencies`. Но существует другой вариант установки пакета. Когда вы устанавливаете пакеты в ваш проект с помощью NPM, вы можете указать тип зависимости для каждого пакета: `dependencies` или `devDependencies`.

**dependencies** – это зависимости, которые необходимы для работы вашего кода в
продакшене – то есть когда вы запускаете или разворачиваете свой проект на
реальном сервере или клиенте. Например, если вы создаёте веб-приложение на
React, то React является зависимостью типа `dependencies`.

**devDependencies** – это зависимости, которые необходимы только для разработки
вашего кода – то есть когда вы пишете, тестируете или отлаживаете свой код на
локальном компьютере. Например, если вы используете Jest для тестирования
своего кода, то Jest является зависимостью типа `devDependencies`.

Разделение зависимостей на два типа помогает оптимизировать размер и скорость
вашего проекта в продакшене, так как вам не нужно устанавливать и загружать
лишние пакеты, которые не используются в продакшн среде.

Для того чтобы установить пакет как зависимость типа dependencies, вы должны
использовать команду `npm install <package-name>` без дополнительных
флагов. Для того чтобы установить пакет как зависимость типа devDependencies, вы
можете использовать команду `npm install <package-name> --save-dev` или
`npm install <package-name> -D`.

## Что такое скрипты NPM?

Вы можете заметить, что в `package.json` есть поле `scripts`. Сюда вы можете помещать различные скрипты, которые вам помогут в разработке.

Скрипты NPM – это способ автоматизировать различные задачи, связанные с вашим
проектом. Вы можете запускать скрипты npm с помощью команды `npm run <script-name>` в командной строке, где `<script-name>` – это название вашего скрипта. Названием скрипта является само поле в объекте `scripts`.

Скрипты npm могут выполнять различные действия, такие как компиляция, форматирование, проверка, тестирование, сборка или публикация вашего кода.

Также вы могли заметить, что в `scripts` есть поле `test` – это тестовый скрипт,
который создаётся по умолчанию в проекте npm. Если запустите этот скрипт `npm run test`, то увидите сообщение в консоли *Error: no test specified*. Базово
этот скрипт нужен для указания команды на запуск тестов. 

## Экспорт из модулей
Экспорт функций и переменных в node.js позволяет использовать их в других
файлах или модулях, позволяя повторно использовать код и упрощая отладку и
поддержку приложения.

Для экспорта функций и переменных в node.js нужно использовать объект
`module.exports`, который является свойством глобального объекта `module`. Этот
объект содержит всё то, что будет доступно для импорта в других файлах или
модулях.

Cоздадим файл в нашем проекте и назовём его math.js добавим туда две функции: `add()` – функция сложения чисел и `subtract()`
```javascript
//math.js
function add(a,b){
    return a + b;
}
function subtract(a,b){
    return a - b;
}
module.exports= {add, subtract}
```

Для импорта функций и переменных в node.js нужно использовать уже знакомую
вам функцию `require()`. Она принимает путь к файлу или модулю, из которого
нужно импортировать. Эта функция возвращает объект с импортированными
данными, который можно сохранить в переменной и использовать для вызова
функций или доступа к переменным.

Например, если мы хотим импортировать функции add и subtract из файла
`math.js` в файл `index.js`, мы можем сделать следующее:
```javascript
//index.js
const math =require('./math')

const result = math.add(3,5);
console.log(result)

const result = math.subtract(3,5);
console.log(result)
```
Обратите внимание на два вызова функции `require()`.
В первом случае `require('uuid')` нет необходимости указывать
относительность пути, то есть добавлять `./` или `../` , так как это
установленный npm пакет.

Во втором случае также можно не указывать относительность пути `./` ,
если файл находится в той же директории, в которой мы импортируем модуль, но следует помнить, что если файл будет находиться в другой директории, например, `libs` , то нам нужно будет вызвать require следующим образом: `require(’./libs/math.js’)`. Для того чтобы не путать локальные файлы с установленными пакетами, рекомендуется всегда указывать относительность пути, как в примере с кодом:
`require(’./math’);`

## Как создать собственный пакет?
Для этого нужно зайти на [официальный сайт NPM] (https://www.npmjs.com/) и в строке поиска ввести любое название пакета, которое вам необходимо. Например, если ввести слово `math`, то мы увидим ряд пакетов, которые содержат в названии, в описании, либо в тегах слово `math`. Нужно придумать название пакета которое свободно.

Теперь давайте создадим новый `npm` проект. Инициализируем проект `npm init -y`

Создадим файл `math.js` и заполним его следующим кодом:
```javascript
//math.js
function add(a,b){
    return a + b;
}
function subtract(a,b){
    return a - b;
}
module.exports= {add, subtract}
```
Также необходимо рядом с `package.json` создать файл `README.md` с описанием
проекта. Это описание будет использоваться на сайте `npm`.

Теперь необходимо подготовить файл package.json

Нужно придумать название нашего пакета и написать в поле `name`. Оно
должно быть уникально в рамках `npm registry`. Проверить уникальность
достаточно просто: нужно зайти на официальный сайт NPM и в поисковой
строке поискать по названию, которое вы хотите дать своему пакету, другие
пакеты с таким же названием. Если поиск не дал результатов – это означает,
что имя не занято и его можно использовать.
* Также нужно добавить описание нашего пакета в поле `description`
* И ещё не забываем указать себя в качестве автора пакета в поле `author`
* Теперь обратите внимание на поле `main` . В этом поле хранится путь до
файла, который будет использован, как файл для импорта.  То есть пользователи, скачавшие ваш пакет, когда в `require()` укажут название вашего пакета, получат результатом выполнения функции `require()` значение, которое экспортируется из модуля. В нашем случае необходимо заменить `index.js` на `math.js`

Теперь публикуем! Для этого необходимо проделать некоторые действия:
* Создайте аккаунт на [NPM](https://www.npmjs.com/) или войдите в свой
существующий аккаунт.
* Подтвердите свой адрес электронной почты.
* В терминале авторизуйтесь в `npm registry` с помощью команды `npm login`.
Эта команда отправит вас в браузер и попросит ввести код из письма на
почте.
* Опубликуйте ваш пакет в` npm registry` с помощью команды `npm publish`
* Проверьте, что ваш пакет появился на сайте [NPM](https://www.npmjs.com/) и
доступен для установки и использования.

Теперь можно устанавливать этот пакет и переиспользовать его код в любом
проекте! Достаточно установить его `npm install name_your_package`.

## Что такое семантическое версионирование?

Давайте теперь разберёмся, как работают версии пакетов в проекте. Для
версионирования пакетов используется семантическое версионирование.

Семантическое версионирование – это система правил и соглашений для
присвоения номеров версий пакетам. Семантическое версионирование помогает
разработчикам понимать, какие изменения произошли в пакете при обновлении его
версии, и как эти изменения могут повлиять на совместимость с другими пакетами.

Семантическое версионирование использует следующий формат для номеров
версий: `major.minor.patch`.
Где:
* **major** – это мажорная версия, которая увеличивается, когда в пакете
происходят серьёзные изменения, которые ломают обратную совместимость
с предыдущими версиями. Например, если в пакете изменяется API,
удаляются функции или меняются зависимости.
* **minor** – это минорная версия, которая увеличивается, когда в пакете
добавляются новые функции или улучшения, которые не ломают обратную
совместимость с предыдущими версиями. Например, если в пакете
добавляются новые опции, параметры или методы.
* **patch** – это патч-версия, которая увеличивается, когда в пакете исправляются
ошибки или баги, которые не влияют на функциональность или
совместимость с предыдущими версиями. Например, если в пакете
исправляются опечатки, улучшается производительность или безопасность.

При изменении более старшей версии, более младшие обнуляются. Например, если
у нас есть версия `2.5.2`и увеличивается минорная версия, то получится `2.6.0`, то
есть патч версия обнулилась.

## Какие ещё есть команды для npm cli?

* `npm help` или `npm h` – выводит справочную информацию о командах `npm cli`;
* `npm uninstall <package-name>` или `npm un <package-name>` – удаляет
пакет из вашего проекта и из файла `package.json`;
* `npm list` или `npm ls` – выводит список всех установленных пакетов в
вашем проекте и их версии;
* `npm view <package-name>` или `npm v <package-name>` – выводит
информацию о пакете из `npm registry`, такую как имя, описание, версия,
лицензия, зависимости и т. д.;
* `npm search <keyword>` или `npm s <keyword>` – ищет пакеты в `npm registry`
по ключевому слову и выводит их названия и описания.
* `npm repo <package-name>` выводит ссылку на репозиторий git проекта

Полный список команд можно посмотреть здесь [NPM](https://docs.npmjs.com/cli/v7/commands)

**Дополнительные материалы**
Официальная документация [NPM](https://docs.npmjs.com/), где вы найдете
подробные инструкции и примеры по использованию NPM и его команд.
● Полное описание правил семантического версионирования https://semver.org/lang/ru/


Словарь терминов
* **Пакет** – это набор файлов кода, который можно установить и использовать в
своём проекте. Пакет может содержать один или несколько модулей
JavaScript, а также другие ресурсы, такие как документация, тесты,
конфигурации и т. д. Пакеты могут быть созданы вами или другими
разработчиками и опубликованы в npm registry.
* **Модуль** – это отдельный файл кода JavaScript, который экспортирует одну
или несколько функций, объектов или переменных. Модуль может быть
импортирован в другой модуль с помощью оператора require или import.
Модули позволяют разбивать код на логические части и повторно
использовать его в разных местах.
* **NPM registry** – это онлайн-репозиторий, в котором хранятся все пакеты,
опубликованные с помощью NPM. Вы можете искать, просматривать и
скачивать пакеты из npm registry с помощью командной строки или браузера.
Вы также можете опубликовать собственные пакеты в npm registry и делиться
ими с другими разработчиками.
* **NPM CLI** – это интерфейс командной строки для работы с NPM. С помощью
NPM CLI вы можете выполнять различные операции с пакетами, такие как
установка, удаление, обновление, просмотр информации и т. д.
* **Проект npm** – это любой каталог на вашем компьютере, который содержит
файл package.json. Файл package.json – это специальный файл в
формате JSON, который содержит метаданные о вашем проекте, такие как
имя, версия, описание, автор, лицензия и т. д. Также в файле package.json
указываются зависимости вашего проекта – то есть пакеты, которые нужны
для работы вашего кода.
* **Семантическое версионирование** – это система правил и соглашений для
присвоения номеров версий пакетам. Семантическое версионирование
помогает разработчикам понимать, какие изменения произошли в пакете при
обновлении его версии, и как эти изменения могут повлиять на
совместимость с другими пакетами.

# Урок 3. Модули и фреймворк Express (WIP)

* Модули в Node.js
* Обзор встроенных модулей
* Глобальные объекты и функции
* Работа с модулями
* Обзор фреймворка express
* Создание http сервера с помощью express

## Модули
Для того чтобы разделить проект Node.js на несколько файлов и переиспользовать функции и переменные необходимо понимать, каким образом обеспечивается экспорт и импорт данных в модулях.

Существует три вида модулей:

* Встроенные модули – эти модули являются частью Node.js. Вы уже знакомы с
одним из таких модулей – это модуль http.
* Модули NPM – эти модули можно установить с помощью NPM. С такими
модулями вы тоже познакомились во второй лекции.
* Пользовательские модули – это модули, которые вы создаёте сами. С этим
видом модулей мы познакомимся более подробно в этой лекции.

## Экспорт данных из модуля

Любой модуль может экспортировать какие-либо данные, чтобы их можно было
переиспользовать в другом модуле. Если представить модуль, как обычную
функцию, то экспорт из модуля – это аналог оператора return. То есть модуль
возвращает какие-то значения во время импорта этого модуля. В Node.js экспорт из модуля реализуется через уже знакомый вам глобальный объект `module.exports`

Из модуля можно экспортировать любые типы данных: функции, строки, числа,
массивы и объекты. По умолчанию `module.exports`– это пустой объект. 

**Необходимо помнить одно правило** – экспорт должен происходить
незамедлительно! Давайте разберём это правило на примере:
```javascript
setTimeout(()=>{
    const someVar =10;
    module.exports = { someVar };
}, 0)
```

`module.exports` определён в колбеке `setTimeout`. Так как `setTimeout` асинхронная функция, то колбек выполнится в будущем. Это означает, что как только мы импортируем модуль с таким кодом, мы не получим в `module.exports` нужные данные, они определятся чуть позже. Именно по этому нельзя использовать `module.exports` в асинхронных функциях.

Вот ещё пример, когда экспорт не будет работать:

```javascript
function exportInFunction () {
    const someVar =10;
    module.exports = { exportInFunction };
}
```

Тут в целом понятно, почему не получится экспортировать данные, так как функция
не вызывается. Если функцию вызвать, то данные будут экспортированы, но так использовать `module.exports` не рекомендуется, так как это будет вас путать.

Хорошим способом экспортировать данные из модуля будет определение
`module.exports` в конце скрипта.

## Импорт модулей

Импортировать модули можно с помощью функции `require().`

Функция `require() `– это глобальная функция Node.js, которая
используется для загрузки и кэширования модулей. Она принимает один
аргумент – `имя` или `путь к файлу модуля`, который нужно загрузить, и
возвращает экспортированные свойства из этого модуля.

Функция `require()` может принять в качестве аргумента имя модуля, если это
глобальный модуль или модуль NPM, либо путь к модулю, если это
пользовательский модуль.

Функция `require() `работает следующим образом:
1. Функция `require()` сначала ищет встроенные модули по переданному имени
модуля.
2. Если глобального модуля с указанным именем нет, то `require()` ищет
установленные модули с помощью NPM.
3. И наконец, если нет ни глобального, ни NPM модулей, или указан путь к
модулю, то ищет среди пользовательских модулей.

Это упрощенный алгоритм работы функции. Если хотите ознакомиться более
подробно с алгоритмом, можете обратиться к [официальной документации](https://nodejs.org/api/modules.html#all-together).


## Пользовательские модули
Чтобы импортировать пользовательский модуль, достаточно в аргумент функции `require()` указать путь к файлу.

Обратите внимание, что путь к модулю указывается относительно модуля, в
котором мы импортируем. Также можно не указывать расширение файла модуля,
`require()` автоматически подставит расширение, если его нет.

Ещё `require()` позволяет импортировать директорию, вместо файла. Для этого
необходимо указать путь к директории и в директории обязательно должен
находиться файл `index.js`

Пример того, как можно импортировать директорию. В директории
`myLib` находится файл `index.js`, который экспортирует объект со свойством hello.
Импортируется эта директория в файле `main.js` и в `require()` указывается путь до
директории импортируемого модуля.

```javascript
// ./mylib/index.js
    module.exports = { hello: 'hello' }
// main.js
    const myLib = require('./mylyb');
```

Такой импорт может пригодиться, когда вы реализуете, к примеру, библиотеку,
которая разбита на несколько файлов. Для того чтобы не думать при импорте, какой
конкретно файл нужно указывать, вы просто можете создать директорию и
определить в ней файл index.js, который будет использоваться для импорта по
умолчанию и при импорте указывать просто путь к директории.

## Импорт по цепочке
Важно понимать, что импортируемые модули могут также импортировать в себя
другие модули.

Первый модуль в этой цепочке – это модуль `baz`, который ничего не импортирует, но
экспортирует данные
```javascript
// baz.js
    module.exports = 'Hello from Baz!'
```
Второй модуль – это модуль `foo`, который импортируем модуль baz и экспортирует
собственные данные.
```javascript
// foo.js
    const baz = require('./baz');
    console.log(baz)
    module.exports = 'Hello from Foo!'
```

И третий модуль – это модуль index, который импортирует модуль `foo`
```javascript
// index..js
    const baz = require('./foo');
    console.log(foo)
```
## Циклические зависимости
Иногда могут возникнуть ситуации, когда цепочка зависимостей начинается и
заканчивается на одном и том же файле. Это называется циклические зависимости.

<image src="./images/8.jpg">

В данном примере `index.js` импортирует `foo.js`. `foo.js`, в свою очередь, импортирует `baz.js`, а `baz.js` импортирует `index.js`. То есть цепочка импортов начинается и заканчивается на одном и том же файле – `index.js`.

Таких зависимостей стоит избегать, так как они ломают работу кода.
## Глобальные объекты и функции

Для удобства некоторая функциональность Node.js реализована не в отдельном
модуле, а представлена глобально. Что это значит? Глобальные объекты и функции Node.js – это объекты и функции, которые доступны во всех модулях без необходимости их подключения с помощью `require()`. Например, `console`, `process` и `__dirname` и т. д. Они являются частью среды исполнения Node.js и определены как глобальные объекты и функции для удобства.

Для использования глобальных объектов и функций Node.js достаточно просто
обратиться к ним по имени.
## Объект global
В Node.js существует глобальный объект global. В этом объекте хранятся различные
объекты и функции, такие как console, Math, setTimeout и т. д.
## Объект process
`process` содержит в себе набор функций и свойств для работы с операционной системой и запущенным процессом Node.js.
```javascript
console.log(process.version) // Версия Node.js
console.log(process.arch) // Архитектура процессора
console.log(process.pid) // id (идентификатор) текущего процесса. 
console.log(process.cwd) // Директория откуда запущен скрипт
console.log('Process Platform', process.platform); // Платформа win32\win86
```
Подробней о process в [документации](https://nodejs.org/api/process.html)

## Свойства `__dirname` и `__filename`
Чтобы определить путь в файловой системе к этому же скрипту,
можно воспользоваться двумя свойствами: `__dirname` и `__filename`

```javascript
console.log(__dirname) // Путь к файлу 
console.log(__filename) // Путь к директории где находится файл 
```

**Обратите внимание** на разницу между `process.cwd()` и `__dirname`. С первого взгляда кажется, что они делают одно и то же, но на самом деле между ними есть
существенное различие: `process.cwd()` возвращает путь к директории, откуда был
запущен скрипт, а `__dirname` возвращает директорию, где скрипт хранится.

Полный список глобальных объектов и функций Node.js можно найти в [официальной документации](https://nodejs.org/api/globals.html).

## Встроенные модули Node.js
Встроенные модули устанавливаются вместе с Node.js и их не нужно устанавливать отдельно.

Встроенные модули предоставляют различные возможности для работы с файлами, сетью, операционной системой, потоками, событиями, криптографией и другими аспектами программирования на Node.js.

### Модуль `fs`
Модуль fs (file system) предоставляет функции для работы с файловой системой. С
его помощью можно читать, записывать, удалять и перемещать файлы и
директории. После подключения модуля мы можем использовать его методы для
работы с файлами.

### Модуль `fs.readFile()`
Для чтения файлов существует метод `fs.readFile()`. Он позволяет получить
содержимое любого файла:
```javascript
// Подключаем модуль
const fs =require('fs');
// Читаем файл hello.txt
fs.readFile('./hello.txt', 'utf-8', (err, data)=>{
    if(err){
        // Если произошла ошибка выводим её
        console.error(err)
    }else{
        // Если нет ошибки выводим содержимое файла
        console.log(data)
    }
})
```
Метод принимает три аргумента:
* путь к файлу, который хотим прочитать;
* кодировку файла (опционально);
* функцию обратного вызова (callback), которая будет вызвана после чтения файла.

Функция обратного вызова в третьем аргументе имеет два аргумента:
* объект ошибки (если произошла ошибка при чтении файла);
* данные файла (если чтение файла успешно).

Метод `fs.readFile()` является асинхронным, то есть он не блокирует выполнение
остального кода до тех пор, пока не прочитает файл. Вместо этого он передаёт
результат чтения файла в функцию обратного вызова, которая будет вызвана
позже.

### Метод `.writeFile()`
Этот метод полностью перезаписывает указанный файл

Метод принимает три аргумента:
* путь к файлу, в который нужно записать данные;
* строка с данными, которые хотим записать;
* функция обратного вызова, которая запустится, когда файл будет записан.

Функция обратного вызова в третьем аргументе принимает один аргумент:
* объект ошибки, который будет инициализирован в случае ошибки записи.

```javascript
// Подключаем модуль
const fs =require('fs');
// Pfgbc файл hello.txt
fs.writeFile('./path/to/file', 'Some text data', (err)=>{
    if(err){
        // Если произошла ошибка выводим её
        console.error(err)
    }else{
        // Если нет ошибки выводим содержимое файла
        console.log('The file was saved')
    }
})
```

### Метод `fs.appendFile()`
Если хочется не перезаписывать файл, а добавлять в файл данные для этого существует метод `fs.appendFile()`.

Этот метод работает очень похожим образом как метод `.writeFile()`

## Синхронные и асинхронные 

Модуль `fs` помимо асинхронных методов имеет также синхронные методы.

Асинхронные методы имеют преимущество в том, что они не замедляют работу
приложения и позволяет обрабатывать множество файлов одновременно. Однако,
это также означает, что порядок выполнения кода может быть неочевидным.

Синхронные же методы блокируют выполнение скрипта до тех пор, пока работа с
файлом не закончится и при этом не требуют определения колбека в третьем
аргументе. Также методы называются по-другому и имеют постфикс Sync.
Например, синхронный аналог метода `fs.readFile()` является `fs.readFileSync()`, а аналогом метода `fs.appendFile()` является `fs.appendFileSync()`.

```javascript
// Подключаем модуль
const fs =require('fs');

try{
    // Если нет ошибки выводим содержимое файла
    const result =fs.readFileSync(__filename, 'utf-8');
    console.log(result)
}
catch(err){
    // Если произошла ошибка выводим её
    console.error(err)
}
```
Как видите, результат чтения файла возвращается функцией `fs.readFileSync()`, а
любые ошибки, которые могут возникнуть во время работы с файлом, необходимо
обрабатывать с помощью `try {} catch {}`

В целом синхронные методы рекомендуется использовать только в тех случаях,
когда вы уверены, что они не повлияют на работу вашего приложения. Например,
если вы делаете `http сервер`, который постоянно слушает входящие запросы, не
стоит использовать синхронные функции, так как они остановят выполнение
вашего кода и ваш сервер не сможет обработать входящие запросы, пока работа с
файлом не будет закончена.

Синхронные методы часто используют при старте приложения, например, чтобы
один раз прочитать какие-нибудь конфигурационные файлы. Или когда реализуют
простой скрипт, который не требует высокой скорости работы. Это допустимые
сценарии использования. Во всех остальных случаях следует воздержаться от
использования синхронных методов.

## Модуль `path`
Модуль path предоставляет ряд методов для работы с путями в файловой системе.
* Метод `path.join()` позволяет объединить две части путей в один путь. Метод
вернёт строку с результатом объединения.

```javascript
const path =require('path');
console.log(path.join('/User/Student', 'Desctop/index.js'))
// Вернет строку '/User/Student/Desctop/index.js'
```
* Метод `path.parse()` возвращает объект пути, в котором хранятся составляющие пути.

```javascript
const path =require('path');
console.log(path.parse('/User/Student/Desctop/index.js'))
// Вернет  следующий объект: 
{
    root:"/",
    dir:"User/Student/Desctop",
    base:"index.js",
    ext: ".js",
    name:"index"
}
```

* Метод `path.dirname()` возвращает путь к директории, исключив название
файла из пути.
```javascript
const path =require('path');
console.log(path.dirname('/User/Student/Desctop/index.js'))
// Вернет строку '/User/Student/Desctop/'
```

* Метод `path.extname()` возвращает расширение файла, который указан в
передаваемом пути
```javascript
const path =require('path');
console.log(path.join('/User/Student/Desctop/index.js'))
// Вернет строку '.js'
```

### Модуль `os`
Модуль `OS` позволяет получить информацию об операционной системе
```javascript
const os =require('os');
// Вернет массив с информацией о ядрах процессора
console.log(os.cpus())
//Вернет информацию об архитектруе процессора
console.log(os.arch())
//Вернет информацию о свободной оперативной памяти
console.log(os.freemem())
//Вернет информацию об общем кол-ве оперативной памяти
console.log(os.totalmem())
// Вернет строку '.js'
```

## Какие ещё модули существуют?

* **`url `**– позволяет работать с URL адресами и их компонентами;
* **`crypto`** – позволяет работать с криптографией. Содержит в себе различные
криптографические функции;
* **`stream`** – позволяет управлять большими потоками данных.

Модули которые есть в Node.js [тут](https://nodejs.org/dist/latest-v18.x/docs/api/)

## Введение в express

Для реализации веб-сервера, конечно же, можно использовать встроенный модуль
`http`, но он довольно низкоуровневый и в случае, если вы сделаете действительно
большой и сложный веб-сервер, код будет читать довольно сложно. В связи с этим
существует множество сторонних библиотек и фреймворков, которые помогают
упростить код и предоставить более высокий уровень абстракции для реализации
`http` сервера. Одним из таких фреймворков – это `express`.

Express – это фреймворк для Node.js, который предоставляет набор функций и
инструментов для создания веб-приложений и API.

Express позволяет легко и быстро создавать веб-сервер, обрабатывать
HTTP-запросы, маршрутизировать URL, работать с промежуточными обработчиками
(middleware), использовать шаблонизаторы для генерации HTML-страниц,
настраивать параметры и переменные окружения, обрабатывать ошибки и многое
другое. Express является минималистичным и гибким фреймворком, который не
навязывает определённой структуры или способа организации кода, а позволяет
разработчику самостоятельно выбирать нужные модули и библиотеки.

## Отличие Express от встроенного пакета http
`Express` построен на основе встроенного пакета `http`, который предоставляет
низкоуровневые функции для работы с HTTP-протоколом. Express расширяет и
упрощает возможности пакета `http`, добавляя высокоуровневые абстракции и
удобные методы для создания веб-приложений. Например, с помощью `Express`
можно легко создать `http` сервер таким образом:

```javascript
const express =require('express');
// Создаем объект приложения
const app =express();
// Создаем обработчик GET-запроса по корневому пути
app.get('/', function (req, res){
        res.send('answer to servet')// отправляем ответ серверу
});
app.listen(3000)// запускаем сервер на порту 3000
```


Express позволяет:
* Использовать методы `app.get()`, `app.post()` и т. д. для определения
обработчиков запросов по разным HTTP-методам и URL-путям.
* Использовать метод `res.send()` для отправки ответа с автоматическим
определением типа контента и кодировки.
* Использовать метод `app.listen()` для запуска сервера на указанном порту.

Кроме того, Express предоставляет множество других возможностей, таких как:

* Поддержка параметров в URL-путях. Например, если вы хотите определить
часть URL, как изменяемую часть.
* Поддержка статических файлов и шаблонизаторов.
* Поддержка промежуточных обработчиков для выполнения различных задач
перед или после обработки запроса.
* Поддержка маршрутизаторов для организации обработчиков по группам или
модулям.
* Поддержка обработки ошибок и специальных ответов (например, 404).
## Установка и запуск Express
Для того чтобы использовать Express в своём проекте, необходимо установить его
как зависимость с помощью NPM. Для этого нужно выполнить следующую команду
в терминале: `npm install express`.

Эта команда установит Express в папку node_modules и добавит его в файл
package.json в раздел dependencies.

```javascript
const express =require('express');
const app =express();
```
Экземпляр приложения `app` представляет собой объект, который содержит методы
для настройки и запуска сервера, а также для определения обработчиков запросов.

Далее необходимо запустить сервер с помощью метода `app.listen()`. Для запуска,
необходимо передать в аргумент метода `.listen()` номер порта, на котором будет
слушать сервер.

```javascript
const express =require('express');
const app =express();
app.listen(3000);
```
Теперь можно определять HTTP обработчики. Это делается вызовом методов `.get()`,
`.post()`, `.put()`, `.delete()` и т. д. на объекте `app`.

```javascript
const express =require('express');
const app =express();
app.get('/', function (req, res){
        res.send('<h1>answer to servet</h1>')
});
app.listen(3000)
```
Определять обработчики можно как до вызова метода `.listen()`, так и после, но лучше определять обработчики до старта сервера, чтобы избежать случаев, когда сервер запущен, но обработчики ещё не инициализировались

Express позволяет определить несколько обработчиков. Например, мы можем
определить обработчик для роута `/about`:
```javascript
const express =require('express');
const app =express();
app.get('/', function (req, res){
        res.send('<h1>answer to servet</h1>')
});
app.get('/about', function (req, res){
        res.send('<h1>Abot page</h1>')
})
app.listen(3000)
```
## Объекты req и res
подробнее разберём колбек в третьем аргументе. Этот колбек
выполняется, когда приходит запрос и в аргументах этого колбека мы можем
получить два объекта.

Первый объект – это объект `req` (request). Этот объект хранит в себе информацию о запросе, такую как: url запроса, метод запроса, информация о клиенте и т. д.

Второй объект – это объект `res` (response). Этот объект хранит в себе свойства и
методы, которые позволяют работать с ответом. Например, метод `.send()` позволяет
завершить запрос и указать данные, которые необходимо вернуть клиенту, а метод
`.status()` позволяет указать `http` статус ответа.
## Промежуточные обработчики
В Express существует концепция промежуточных обработчиков или middleware.
Такие обработчики нужны, для того чтобы задавать дополнительную логику для
основных обработчиков.

<image src="./images/9.jpg">

Существует два вида промежуточных обработчиков: глобальные и локальные.
* Глобальные промежуточные обработчики не привязаны к конкретному роуту
и отрабатывают для группы роутов или абсолютно для всех роутов.
* Локальные промежуточные обработчики определяются для конкретного
роута.

## Глобальные промежуточные обработчики
```javascript
const express =require('express');
const app =express();
// Логируем факт запроса
app.use((req, res, next)=>{
    console.log('Поступил запрос', req.method, req.url);
    next();
})
app.get('/', function (req, res){
        res.send('<h1>answer to servet</h1>')
});
app.get('/about', function (req, res){
        res.send('<h1>Abot page</h1>')
})
app.listen(3000)
```
Допустим, мы хотим логировать любой входящий запрос. Чтобы не писать логику
логирования в каждом роуте, можно добавить глобальный промежуточный
обработчик до определения всех роутов. Реализуется это с помощью метода
`app.use()` На шестой строке вы можете увидеть, что метод принимает один
единственный аргумент в виде колбека, который очень похож на колбек в обычном
обработчике. В первом аргументе можно получить объект запроса, во втором –
объект ответа, а третий аргумент хранит в себе функцию `next()`.

Функция `next() `необходима для того чтобы продолжить вызов следующих
обработчиков. Если функцию `next() `не вызвать, то обработчики роутов не
запустятся и запрос зависнет. То есть в промежуточном обработчике мы должны
сообщить `express-у`, когда стоит запускать следующие обработчики.

**Важно понимать, что порядок определения обработчиков очень важен!** 

Например, если в примере выше мы определим промежуточный
обработчик после основных обработчиков роутов, то промежуточный
обработчик никогда не выполнится.

Но существуют ситуации, когда промежуточный обработчик, определённый после
основных обработчиков роутов, будет работать. Это может произойти в том случае,
если не был найден нужный обработчик роута.

```javascript
const express =require('express');
const app =express();

app.get('/', function (req, res){
        res.send('<h1>answer to servet</h1>')
});

app.use((req, res)=>{
    res.status(404)
    console.log('Поступил запрос', req.method, req.url);
    res.send('<h1>Страница не найдена</h1>')
})
app.listen(3000);
```
В коде выше определён один единственный обработчик для
корневого роута. После определения этого обработчика, определён промежуточный обработчик, в котором устанавливается статус ответа `res.status(404);` и отправляется HTML клиенту. Если запустить этот код и попробовать обратиться к неопределённому роуту, например, к `/about`, то запуститься промежуточный обработчик `app.use()`. Это происходит потому, что express ищет обработчик для переданного url, и если такого обработчика нет, то запускается следующий глобальный обработчик по порядку. В нашем случае этот обработчик отправляет информацию клиенту о том, что страница не найдена.

Вот так просто в `express` реализовать обработку несуществующих роутов, для этого
достаточно определить глобальный обработчик после всех основных.

## Локальные промежуточные обработчики
```javascript
const express =require('express');
const app =express();

function logRequest(req, res, next){
    console.log('Поступил запрос', req.method, req.url);
    next();
}
app.get('/',  logRequest, (req, res){
        res.send('<h1>answer to server</h1>')
});
app.listen(3000);
```
В примере выше  определена функция `logRequest` промежуточного
обработчика, которая логирует запрос. Далее обратите внимание определённый выше промежуточный обработчик, передан во второй аргумент, а в третьем уже определён основной обработчик. На самом деле `express`, при вызове методов определения обработчиков, принимает любое количество аргументов. То есть начиная со второго аргумента, `express` вызывает все указанные далее в аргументах обработчики по порядку.


```javascript
const express =require('express');
const app =express();

function logRequest(req, res, next){
    console.log('Поступил запрос', req.method, req.url);
    next();
}
app.get('/',  logRequest, logRequest, logRequest, (req, res){
        res.send('<h1>answer to server</h1>')
});
app.listen(3000);
```
В примере выше переданы друг за другом три промежуточных обработчика, и
только потом определён основной обработчик роута. Запустив этот код, при
запросе на ваш роут, вы получите три сообщения в консоли.

Также можно определить промежуточный обработчик прямо в вызове метода, как и
основной обработчик:
```javascript
const express =require('express');
const app =express();


app.get('/', 
    (req, res, next) {
        console.log('Поступил запрос', req.method, req.url);
        next();
    },
    (req, res){
        res.send('<h1>answer to server</h1>')
    }
);
app.listen(3000);
```

Локальные промежуточные обработчики позволяют определить уникальное
поведение для определённых роутов. Например, аутентификацию запроса можно
реализовать с помощью локального промежуточного обработчика, один раз
определив функцию такого обработчика и добавляя её только в те роуты, где
пользователи должны быть аутентифицированны.
## Переменные в URL
Иногда вам может понадобиться иметь динамическую часть URL. Например, когда
вы реализуете сайт со статьями, где номер каждой статьи определён в URL, к
пример так: `/article/83774`. В таком URL динамической частью является
идентификатор статьи. Заранее, скорее всего, вам не будет известно сколько будет
статей и какие у них будут идентификаторы, и делать под каждую статью
обработчик будет довольно затратно, поэтому в express существует механизм URL
переменных. Давайте рассмотрим пример кода:
```javascript
const express =require('express');
const app =express();
app.get('/article/:id', (req, res) {
    res.send('<h1>Article № ${req.params.id}</h1>')
});
app.listen(3000);
```

Обратите внимание на первый аргумент. В него передаётся
строка `/article/:id`, где `:id` `express` расценивает, как динамическую часть URL. Динамическую часть URL вы можете именовать как угодно, например,
`/article/:articleID`. Таким образом в браузере можно сделать запрос на сервер с
таким URL `/article/748` и `express` запустит, этот обработчик.

Далее мы возвращаем клиенту заголовок, в который передаем номер статьи из URL. Данные, указанные в динамической части URL, хранятся в объекте `req` в свойстве `params`. Получить данные, которые были переданы из бразуера, можно по названию, который вы определили в URL – это `id`. 

Вы можете определить несколько переменных в URL. Предположим, что под
статьями можно оставлять комментарии и у каждого комментария свой
идентификатор. В таком случае, чтобы получить текст какого-то конкретного
комментария, необходимо определить следующий роут:
`/article/:articleID/comments/:commentID.`

Номер статьи можно получить в свойстве `req.params.articleID`, а номер комментария в свойстве `req.params.commentID`.

## Пропуск символов в URL
Ещё иногда вам может понадобиться сделать ваши URL более “дружелюбными” для
пользователей. Например, когда вы знаете, что пользователь может ошибиться в
URL, к примеру, в слове comment написать одну букву m. Для таких случаев `express` позволяет пропускать символы. Давайте посмотрим пример:
```javascript
const express =require('express');
const app =express();
app.get('/com?ment/', (req, res) {
    res.send('com?ment')
});
app.listen(3000);
```

в первом аргументе в слове comment указан специальный символ
`?`, который позволяет сделать запрос как на URL `/comment`, так и на `/coment`. Знак вопроса говорит `express` о том, что последующий за этим знаком символ может быть пропущен.

## Повторение символов в URL
Также можно указать, какие символы могут быть повторены несколько раз. Для
этого необходимо использовать знак `+`. Например:

```javascript
const express =require('express');
const app =express();
app.get('/add+ress', (req, res) {
    res.send('add+ress')
});
app.listen(3000);
```
В первом аргументе в слове `address` добавлен знак `+` после второй
буквы `d`, и это означает, что предыдущий символ в URL можно указывать сколько
угодно раз. Например, так `adddress` или так `adddddddress`.
## Любые символы в URL
Ещё есть возможность в URL, что могут быть повторены любые символы. Для этого
необходимо использовать знак `*`. Например
```javascript
const express =require('express');
const app =express();
app.get('/add*ress', (req, res) {
    res.send('add*ress')
});
app.listen(3000);
```
В этом примере в роуте, между буквой `d` и `r` можно указать любые символы в любом количестве.
## Возврат HTML файла
До сих пор во всех примерах вы могли наблюдать, что HTML конечному клиенту
передаётся в виде строки прямо в коде. Но HTML код может быть большим и
держать его в строке будет не очень удобно. В express существует для этого
возможность возврата файла в качестве ответа на запрос с помощью метода
`res.sendFile()`. Допустим, существует скрипт сервера и в этой же директории
находится файл `index.html`, который мы хотим использовать в качестве ответа.

```javascript
const express =require('express');
const app =express();
app.get('/', (req, res) {
    res.sendFile(path.join(__dirname, '/index.html')  )
});
app.l
```
Здесь происходит вызов метода `app.sendFile()` и в первый аргумент
этого метода передаётся строка с путём к HTML файлу. Путь к файлу должен быть
абсолютным, именно поэтому в примере используется модуль `path` и его метод
`path.join()`. Также используется глобальное свойство `__dirname`, которое хранит
информацию о том, в какой директории находится скрипт. Таким образом, передав
в `path.join()` две составляющие: `__dirname` и название файла, метод возвращает
полный путь к HTML файлу.
## Статичные файлы
Ещё express позволяет определить директорию, файлы которой будут доступны из
браузера. Такие файлы называются статичными. Для того чтобы определить такую
директорию, необходимо использовать промежуточный обработчик `express.static()`.
Давайте посмотрим на пример:

```javascript
const express =require('express');
const app =express();
app.use(express.static('static'));
app.get('/', (req, res) {
    res.sendFile(path.join('static/index.html')  )
});
app.listen(3000);
```
Здесь используется метод ``app.use()`` для регистрации глобального
промежуточного обработчика. В первый аргумент метода `app.use()` передаётся
результат выполнения функции `express.static(‘static’)` которая, в свою очередь,
принимает в первом аргументе путь к директории, где хранятся статичные файлы.
Обычно такую директорию называют static. Далее на восьмой строке в метод
`res.sendFile()` передаётся путь к HTML файлу, текст которого необходимо вернуть вкачестве ответа. При этом можно не указывать абсолютный путь к файлу,
достаточно указать путь от директории, в которой хранятся статические файлы.

Помимо всего прочего, статические файлы можно запросить прямо из браузера.
Допустим, в директории static хранится два файла: index.html и about.html. Для того чтобы получить их содержимое, можно не писать отдельный роут, а просто указать имя файла прямо в URL таким образом: `http://localhost:3000/index.html` или `http://localhost:3000/about.html`

## Использование статичных файлов
Чаще всего, HTML страницы реализуются в паре с таблицами стилей. Для того чтобы
в HTML использовать CSS файлы, можно воспользоваться механизмом раздачи
статичных файлов. Допустим, у вас есть такой HTML файл:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>my site</title>
</head>
<body>
        <h1>Main page</h1>
</body>
</html>
```
Чтобы подключить стили к этому файлу, необходимо в заголовок добавить тег
`<link/>`. В самом теге необходимо определить атрибут `href`, в котором нужно указать ссылку на CSS файл. Так как в директорию со статическими файлами можно
поместить любые файлы, это как раз позволяет создать файл `index.css` в этой
директории и ссылаться на него в HTML файле

Также можно посмотреть содержимое файла CSS в браузере. Достаточно напрямую
к нему обратиться `http://localhost:3000/index.css`.

Официальная документация [express](http://expressjs.com/ru)